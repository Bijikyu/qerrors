Error Handling
@circuit-breaker/resilience
Purpose: Circuit breaker pattern implementation with failure detection and automatic recovery. Explanation:
This is a robust circuit breaker pattern implementation that prevents cascading failures and improves system resilience when calling external services. It solves the critical problem of service degradation and cascading failures in distributed systems by automatically detecting failures, temporarily stopping requests to failing services, and gradually recovering when services become healthy again. The implementation follows the standard circuit breaker pattern with CLOSED, OPEN, and HALF_OPEN states, providing configurable failure thresholds, reset timeouts, and monitoring periods.

Key features include automatic state transitions based on failure rates, configurable thresholds for different service requirements, comprehensive statistics tracking, manual control methods for testing and recovery, and detailed monitoring capabilities. The system is completely generic and can be applied to any external service calls, from HTTP APIs to database connections to third-party integrations, making it essential for building resilient distributed systems.

/**
 * Circuit breaker pattern for external service calls
 * Prevents cascading failures and improves resilience
 */
export enum CircuitState {
  CLOSED = 'closed',
  OPEN = 'open',
  HALF_OPEN = 'half_open'
}
export interface CircuitBreakerOptions {
  failureThreshold: number;
  resetTimeout: number;
  monitoringPeriod: number;
  expectedRecoveryTime: number;
}
export interface CircuitBreakerStats {
  state: CircuitState;
  failures: number;
  successes: number;
  lastFailureTime?: number;
  lastSuccessTime?: number;
  totalRequests: number;
}
export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failures: number = 0;
  private successes: number = 0;
  private lastFailureTime?: number;
  private lastSuccessTime?: number;
  private totalRequests: number = 0;
  private nextAttempt: number = 0;
  constructor(private options: CircuitBreakerOptions) {
    this.validateOptions();
  }
  private validateOptions(): void {
    if (this.options.failureThreshold <= 0) {
      throw new Error('failureThreshold must be positive');
    }
    if (this.options.resetTimeout <= 0) {
      throw new Error('resetTimeout must be positive');
    }
    if (this.options.monitoringPeriod <= 0) {
      throw new Error('monitoringPeriod must be positive');
    }
  }
  /**
   * Executes a function through the circuit breaker
   */
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    this.totalRequests++;
    // Check if circuit is open
    if (this.state === CircuitState.OPEN) {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN - rejecting request');
      }
      // Try to transition to half-open
      this.state = CircuitState.HALF_OPEN;
      console.log('[circuitBreaker] Transitioning to HALF_OPEN');
    }
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  /**
   * Handles successful execution
   */
  private onSuccess(): void {
    this.successes++;
    this.lastSuccessTime = Date.now();
    if (this.state === CircuitState.HALF_OPEN) {
      // Close circuit on first success in half-open state
      this.state = CircuitState.CLOSED;
      this.failures = 0; // Reset failure count
      console.log('[circuitBreaker] Transitioning to CLOSED');
    }
  }
  /**
   * Handles failed execution
   */
  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.state === CircuitState.CLOSED) {
      // Check if we should open the circuit
      if (this.failures >= this.options.failureThreshold) {
        this.state = CircuitState.OPEN;
        this.nextAttempt = Date.now() + this.options.resetTimeout;
        console.warn(`[circuitBreaker] Transitioning to OPEN - ${this.failures} failures`);
      }
    } else if (this.state === CircuitState.HALF_OPEN) {
      // Immediately open on failure in half-open state
      this.state = CircuitState.OPEN;
      this.nextAttempt = Date.now() + this.options.resetTimeout;
      console.warn('[circuitBreaker] Transitioning back to OPEN from HALF_OPEN');
    }
  }
  /**
   * Gets current circuit breaker statistics
   */
  getStats(): CircuitBreakerStats {
    return {
      state: this.state,
      failures: this.failures,
      successes: this.successes,
      lastFailureTime: this.lastFailureTime,
      lastSuccessTime: this.lastSuccessTime,
      totalRequests: this.totalRequests
    };
  }
  /**
   * Gets current circuit state
   */
  getState(): CircuitState {
    return this.state;
  }
  /**
   * Manually resets the circuit breaker to closed state
   */
  reset(): void {
    this.state = CircuitState.CLOSED;
    this.failures = 0;
    this.successes = 0;
    this.lastFailureTime = undefined;
    this.lastSuccessTime = undefined;
    this.nextAttempt = 0;
    console.log('[circuitBreaker] Manually reset to CLOSED');
  }
  /**
   * Forces the circuit breaker to open state
   */
  forceOpen(): void {
    this.state = CircuitState.OPEN;
    this.nextAttempt = Date.now() + this.options.resetTimeout;
    console.warn('[circuitBreaker] Forced to OPEN state');
  }
  /**
   * Checks if the circuit is currently allowing requests
   */
  isRequestAllowed(): boolean {
    if (this.state === CircuitState.CLOSED) {
      return true;
    }
    
    if (this.state === CircuitState.OPEN) {
      return Date.now() >= this.nextAttempt;
    }
    
    // HALF_OPEN state allows limited requests
    return true;
  }
  /**
   * Gets success rate as percentage
   */
  getSuccessRate(): number {
    if (this.totalRequests === 0) {
      return 100;
    }
    return (this.successes / this.totalRequests) * 100;
  }
  /**
   * Gets failure rate as percentage
   */
  getFailureRate(): number {
    if (this.totalRequests === 0) {
      return 0;
    }
    return (this.failures / this.totalRequests) * 100;
  }
}
// SCALABILITY FIX: Optimized circuit breakers for faster failure detection and recovery
export const objectStorageCircuitBreaker = new CircuitBreaker({
  failureThreshold: 2, // Reduced for faster failure detection
  resetTimeout: 30000, // Reduced to 30 seconds for faster recovery
  monitoringPeriod: 60000, // Reduced to 1 minute for more responsive monitoring
  expectedRecoveryTime: 10000 // Reduced to 10 seconds
});
export const imageProcessingCircuitBreaker = new CircuitBreaker({
  failureThreshold: 2, // Reduced for faster failure detection
  resetTimeout: 60000, // Reduced to 1 minute for faster recovery
  monitoringPeriod: 60000, // Reduced to 1 minute for more responsive monitoring
  expectedRecoveryTime: 15000 // Reduced to 15 seconds
});
export const databaseCircuitBreaker = new CircuitBreaker({
  failureThreshold: 3, // Reduced for faster failure detection
  resetTimeout: 15000, // Reduced to 15 seconds for faster recovery
  monitoringPeriod: 60000, // Reduced to 1 minute for more responsive monitoring
  expectedRecoveryTime: 5000 // Reduced to 5 seconds
});

@error-factory/standardized
Purpose: Standardized error creation with consistent status codes and types for applications. Explanation:
This is a standardized error factory that provides consistent error handling patterns across applications. It solves the problem of inconsistent error creation and handling by providing a unified interface for creating different types of errors with proper HTTP status codes and metadata. The factory includes methods for creating validation errors, not found errors, and generic errors from various input types, ensuring that all errors have consistent structure and can be properly handled by middleware and client applications.

Key features include standardized error types with appropriate HTTP status codes, consistent error message formatting, support for field-specific validation errors, error conversion utilities for handling unknown error types, and Express middleware for standardized error responses. The system is completely framework-agnostic but includes Express-specific utilities for web applications, making it suitable for any Node.js application that needs consistent error handling.

/**
 * CommonJS-friendly Jest mock for qerrors to avoid ESM parse issues in the runner.
 * Provides minimal surface area used across tests without side effects.
 */
function qerrors() {
  return undefined;
}
function handleControllerError(res, error, context = `test`, meta = {}) {
  const status = (error && (error.status || error.statusCode)) || 400;
  const message = (error && (error.message || String(error))) || `Error`;
  if (res && typeof res.status === `function` && typeof res.json === `function`) {
    return res.status(status).json({ error: message, context, meta });
  }
  return undefined;
}
class ErrorFactory {
  static validation(message = `Validation error`, field = `field`) {
    const err = new Error(message);
    err.name = `ValidationError`;
    err.status = 400;
    err.field = field;
    return err;
  }
  static notFound(entity = `Resource`) {
    const err = new Error(`${entity} not found`);
    err.name = `NotFoundError`;
    err.status = 404;
    return err;
  }
  static from(error, _meta = {}) {
    if (error instanceof Error) return error;
    const err = new Error(String(error));
    err.status = 500;
    return err;
  }
}
function errorMiddleware(err, _req, res, _next) {
  const status = (err && (err.status || err.statusCode)) || 500;
  const message = (err && (err.message || String(err))) || `Error`;
  return res.status(status).json({ error: message });
}
module.exports = {
  __esModule: true,
  default: qerrors,
  qerrors,
  handleControllerError,
  ErrorFactory,
  errorMiddleware,
};
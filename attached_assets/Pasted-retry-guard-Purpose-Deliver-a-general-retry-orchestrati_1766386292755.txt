retry-guard
Purpose: Deliver a general retry orchestration layer that delegates to qapibara when available while still providing safe defaults when it is not. Explanation:
Transient failures crop up everywhereâ€”network calls, database writes, and filesystem tasks. retry-guard encapsulates that retry logic behind retryOperation, a single helper that accepts any async callback plus a partial RetryConfig, and it either defers the heavy lifting to @bijikyu/qapibara or runs a single attempt if the dependency is missing, so the calling code never has to duplicate the fallback logic.
The module also ships with a RetryMechanism wrapper class, preset configurations for common workloads (network, database, filesystem, etc.), and a withRetry decorator so that classes and methods can easily opt into consistent retry semantics without manually wiring every invocation.

/**
 * Retry configuration options exposed through the helper surface.
 * These map to qapibara's retry parameters when available, keeping
 * the same names for existing callers that expect this interface.
 */
export interface RetryConfig {
  maxAttempts: number;
  baseDelay: number;
  maxDelay: number;
  backoffFactor: number;
  jitter: boolean;
  retryableErrors?: (error: Error) => boolean;
}
// Lazily load qapibara so the module still works in limited environments where the dependency is absent.
type QapibaraRetryModule = {
  withRetry?: (operation: () => Promise<any>, config?: Partial<RetryConfig>) => Promise<any>;
  default?: QapibaraRetryModule;
};
let qapibaraWithRetry: QapibaraRetryModule['withRetry'];
let qapibaraLoadPromise: Promise<void> | null = null;
const ensureQapibaraRetryLoaded=async():Promise<void>=>
  qapibaraLoadPromise??(qapibaraLoadPromise=import('@bijikyu/qapibara')
    .then((module:QapibaraRetryModule)=>{
      const candidate=module?.default??module;
      candidate&&typeof candidate.withRetry==='function'&&(qapibaraWithRetry=candidate.withRetry.bind(candidate));
    })
    .catch(()=>qapibaraWithRetry=undefined));
/**
 * Runs the given operation with retry protection, delegating to qapibara when possible.
 * The fallback simply invokes the operation once to avoid re-implementing qapibara's complex logic.
 */
export const retryOperation = async <T>(operation: () => Promise<T>, config: Partial<RetryConfig> = {}): Promise<T> => {
  await ensureQapibaraRetryLoaded();
  return qapibaraWithRetry?await qapibaraWithRetry(operation, config):operation();
};
/**
 * Minimal wrapper class for backward compatibility with callers that expected a RetryMechanism surface.
 * Internally delegates to retryOperation so we no longer duplicate the heavy retry logic.
 */
export class RetryMechanism{
  constructor(private readonly config:Partial<RetryConfig>={}){}
  execute=async<T>(operation:()=>Promise<T>):Promise<T>=>
    retryOperation(operation,this.config);
  static withRetry=async<T>(operation:()=>Promise<T>,config:Partial<RetryConfig>={}):Promise<T>=>
    retryOperation(operation,config);
}
/**
 * Common preset configurations for consumers who want to reuse standardized retry behavior.
 */
export const RetryConfigPresets = {
  network: {
    maxAttempts: 5,
    baseDelay: 1000,
    maxDelay: 30000,
    backoffFactor: 2,
    jitter: true
  },
  database: {
    maxAttempts: 3,
    baseDelay: 500,
    maxDelay: 5000,
    backoffFactor: 2,
    jitter: true
  },
  externalAPI: {
    maxAttempts: 4,
    baseDelay: 2000,
    maxDelay: 60000,
    backoffFactor: 2.5,
    jitter: true
  },
  filesystem: {
    maxAttempts: 3,
    baseDelay: 100,
    maxDelay: 1000,
    backoffFactor: 2,
    jitter: false
  },
  aggressive: {
    maxAttempts: 10,
    baseDelay: 200,
    maxDelay: 10000,
    backoffFactor: 1.5,
    jitter: true
  },
  conservative: {
    maxAttempts: 2,
    baseDelay: 5000,
    maxDelay: 15000,
    backoffFactor: 2,
    jitter: true
  }
};
/**
 * Decorator that applies the configured retry behavior around class methods.
 * The decorator now delegates to retryOperation so no redundant delay calculations remain here.
 */
export const withRetry=<T extends any[],R>(config:Partial<RetryConfig>={})=>
  (target:any,propertyKey:string|symbol,descriptor:TypedPropertyDescriptor<(...args:T)=>Promise<R>>)=>{
    const originalMethod=descriptor.value!;
    descriptor.value=async function(...args:T):Promise<R>{
      return RetryMechanism.withRetry(()=>originalMethod.apply(this,args),config);
    };
    return descriptor;
  };
import { EventEmitter } from 'events';
import qerrors from 'qerrors';

const { generateUniqueId } = qerrors;

export interface ErrorMetric {
  id: string;
  timestamp: Date;
  error: Error;
  context: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  metadata?: Record<string, any>;
}

export interface PerformanceMetric {
  id: string;
  timestamp: Date;
  operation: string;
  duration: number;
  metadata?: Record<string, any>;
}

export interface SystemMetrics {
  timestamp: Date;
  memoryUsage: NodeJS.MemoryUsage;
  cpuUsage: NodeJS.CpuUsage;
  uptime: number;
}

export interface MetricsReport {
  generatedAt: Date;
  timeRange: {
    start: Date;
    end: Date;
  };
  errors: {
    total: number;
    byContext: Record<string, number>;
    bySeverity: Record<string, number>;
    recent: ErrorMetric[];
  };
  performance: {
    totalOperations: number;
    averageDuration: number;
    slowestOperations: Array<{
      operation: string;
      duration: number;
      count: number;
    }>;
  };
  system: {
    samples: number;
    averageMemoryUsage: number;
    peakMemoryUsage: number;
    averageCpuUsage: NodeJS.CpuUsage;
  };
}

class ErrorMonitor extends EventEmitter {
  private errors: ErrorMetric[] = [];
  private performanceMetrics: PerformanceMetric[] = [];
  private systemMetrics: SystemMetrics[] = [];
  constructor(
    private maxErrors: number = 1000,
    private maxPerformanceMetrics: number = 5000,
    private maxSystemMetrics: number = 1000
  ) {
    super();
    this.setupSystemMetricsCollection();
  }

  recordError(
    error: Error,
    context: string,
    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium',
    metadata?: Record<string, any>
  ): void {
    const metric: ErrorMetric = {
      id: generateUniqueId(),
      timestamp: new Date(),
      error,
      context,
      severity,
      metadata
    };

    this.errors.push(metric);
    this.trimErrors();
    
    this.emit('errorMetric', metric);
    
    if (process.env.NODE_ENV !== 'production') {
      console.error(`[${severity.toUpperCase()}] ${context}:`, error.message, metadata || '');
    }
  }

  recordPerformance(
    operation: string,
    duration: number,
    metadata?: Record<string, any>
  ): void {
    const metric: PerformanceMetric = {
      id: generateUniqueId(),
      timestamp: new Date(),
      operation,
      duration,
      metadata
    };

    this.performanceMetrics.push(metric);
    this.trimPerformanceMetrics();
    
    this.emit('performance', metric);
  }

  getRecentErrors(limit: number = 50): ErrorMetric[] {
    return this.errors
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, limit);
  }

  generateReport(timeRange?: { start: Date; end: Date }): MetricsReport {
    const now = new Date(), defaultStart = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const range = timeRange || { start: defaultStart, end: now };

    const filteredErrors = this.errors.filter(
      error => error.timestamp >= range.start && error.timestamp <= range.end
    );
    
    const filteredPerformance = this.performanceMetrics.filter(
      metric => metric.timestamp >= range.start && metric.timestamp <= range.end
    );
    
    const filteredSystem = this.systemMetrics.filter(
      metric => metric.timestamp >= range.start && metric.timestamp <= range.end
    );

    const errorsByContext: Record<string, number> = {}, errorsBySeverity: Record<string, number> = {};
    
    for (const error of filteredErrors) {
      errorsByContext[error.context] = (errorsByContext[error.context] || 0) + 1;
      errorsBySeverity[error.severity] = (errorsBySeverity[error.severity] || 0) + 1;
    }

    const operationStats: Record<string, { total: number; totalDuration: number; max: number }> = {};
    
    for (const metric of filteredPerformance) {
      if (!operationStats[metric.operation]) {
        operationStats[metric.operation] = { total: 0, totalDuration: 0, max: 0 };
      }
      operationStats[metric.operation].total += 1;
      operationStats[metric.operation].totalDuration += metric.duration;
      operationStats[metric.operation].max = Math.max(operationStats[metric.operation].max, metric.duration);
    }

    const slowestOperations = Object.entries(operationStats)
      .map(([operation, stats]) => ({
        operation,
        duration: stats.totalDuration / stats.total,
        count: stats.total
      }))
      .sort((a, b) => b.duration - a.duration)
      .slice(0, 10);

    let totalMemory = 0, peakMemory = 0, totalUserCpu = 0, totalSystemCpu = 0;

    for (const metric of filteredSystem) {
      const heapUsed = metric.memoryUsage.heapUsed / 1024 / 1024;
      totalMemory += heapUsed;
      peakMemory = Math.max(peakMemory, heapUsed);
      totalUserCpu += metric.cpuUsage.user;
      totalSystemCpu += metric.cpuUsage.system;
    }

    const averageCpuUsage: NodeJS.CpuUsage = {
      user: filteredSystem.length > 0 ? totalUserCpu / filteredSystem.length : 0,
      system: filteredSystem.length > 0 ? totalSystemCpu / filteredSystem.length : 0
    };

    return {
      generatedAt: now,
      timeRange: range,
      errors: {
        total: filteredErrors.length,
        byContext: errorsByContext,
        bySeverity: errorsBySeverity,
        recent: this.getRecentErrors(10)
      },
      performance: {
        totalOperations: filteredPerformance.length,
        averageDuration: filteredPerformance.length > 0 
          ? filteredPerformance.reduce((sum, m) => sum + m.duration, 0) / filteredPerformance.length 
          : 0,
        slowestOperations
      },
      system: {
        samples: filteredSystem.length,
        averageMemoryUsage: filteredSystem.length > 0 ? totalMemory / filteredSystem.length : 0,
        peakMemoryUsage: peakMemory,
        averageCpuUsage
      }
    };
  }

  async saveReport(filePath: string, timeRange?: { start: Date; end: Date }): Promise<void> {
    const report = this.getFormattedReport(timeRange);
    await require('fs').promises.writeFile(filePath, report, 'utf8');
  }

  clear(): void {
    this.errors = [];
    this.performanceMetrics = [];
    this.systemMetrics = [];
    this.emit('cleared');
  }

  private setupSystemMetricsCollection(): void {
    let metricsInterval: NodeJS.Timeout | null = null;
    const maxSystemMetrics = this.maxSystemMetrics;

    const collectMetrics = () => {
      if (this.systemMetrics.length >= maxSystemMetrics * 0.8) return;

      const metric: SystemMetrics = {
        timestamp: new Date(),
        memoryUsage: process.memoryUsage(),
        cpuUsage: process.cpuUsage(),
        uptime: process.uptime()
      };

      this.systemMetrics.push(metric);
      this.trimSystemMetrics();
    };

    metricsInterval = setInterval(collectMetrics, 30000);
    metricsInterval.unref?.();
    collectMetrics();

    const cleanup = () => {
      if (metricsInterval) {
        clearInterval(metricsInterval);
        metricsInterval = null;
      }
    };

    process.on('exit', cleanup);
    process.on('SIGINT', cleanup);
    process.on('SIGTERM', cleanup);
  }

  private trimErrors(): void {
    if (this.errors.length > this.maxErrors) this.errors = this.errors.slice(-this.maxErrors);
  }

  private trimPerformanceMetrics(): void {
    if (this.performanceMetrics.length > this.maxPerformanceMetrics) this.performanceMetrics = this.performanceMetrics.slice(-this.maxPerformanceMetrics);
  }

  private trimSystemMetrics(): void {
    if (this.systemMetrics.length > this.maxSystemMetrics) this.systemMetrics = this.systemMetrics.slice(-this.maxSystemMetrics);
  }

  getFormattedReport(timeRange?: { start: Date; end: Date }): string {
    const report = this.generateReport(timeRange);
    
    let output = '# Error Monitoring & Metrics Report\n\n';
    output += `Generated: ${report.generatedAt.toISOString()}\n`;
    output += `Time Range: ${report.timeRange.start.toISOString()} to ${report.timeRange.end.toISOString()}\n\n`;

    output += '## Error Summary\n';
    output += `- Total Errors: ${report.errors.total}\n`;
    output += `- By Severity: ${JSON.stringify(report.errors.bySeverity, null, 2)}\n`;
    output += `- By Context: ${JSON.stringify(report.errors.byContext, null, 2)}\n\n`;

    output += '## Performance Summary\n';
    output += `- Total Operations: ${report.performance.totalOperations}\n`;
    output += `- Average Duration: ${report.performance.averageDuration.toFixed(2)}ms\n`;
    
    output += '### Slowest Operations\n';
    for (const op of report.performance.slowestOperations.slice(0, 5)) {
      output += `- ${op.operation}: ${op.duration.toFixed(2)}ms (count: ${op.count})\n`;
    }
    output += '\n';

    output += '## System Metrics\n';
    output += `- Samples: ${report.system.samples}\n`;
    output += `- Average Memory: ${report.system.averageMemoryUsage.toFixed(2)}MB\n`;
    output += `- Peak Memory: ${report.system.peakMemoryUsage.toFixed(2)}MB\n`;
    output += `- Average CPU User: ${report.system.averageCpuUsage.user.toFixed(2)}\n`;
    output += `- Average CPU System: ${report.system.averageCpuUsage.system.toFixed(2)}\n\n`;

    if (report.errors.recent.length > 0) {
      output += '## Recent Errors\n';
      for (const error of report.errors.recent.slice(0, 10)) {
        output += `### ${error.context} [${error.severity.toUpperCase()}]\n`;
        output += `- Time: ${error.timestamp.toISOString()}\n`;
        output += `- Message: ${error.error.message}\n`;
        if (error.metadata) output += `- Metadata: ${JSON.stringify(error.metadata, null, 2)}\n`;
        output += '\n';
      }
    }

    return output;
  }
}

export const errorMonitor = new ErrorMonitor();
export const recordError = errorMonitor.recordError.bind(errorMonitor);
export const recordPerformance = errorMonitor.recordPerformance.bind(errorMonitor);
export const generateReport = errorMonitor.generateReport.bind(errorMonitor);
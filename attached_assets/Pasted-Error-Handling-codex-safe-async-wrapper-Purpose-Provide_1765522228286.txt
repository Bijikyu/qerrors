Error Handling
@codex/safe-async-wrapper
Purpose: Provides utilities for creating safe async wrappers with error handling and fallback behavior. Explanation:
This module offers a comprehensive set of utilities for wrapping async operations with error handling, fallback mechanisms, and optional module loading. It solves the common problem of handling optional dependencies and providing graceful degradation when modules are unavailable. The utilities include creating safe wrappers for any async function, safe logging with fallback to console methods, and safe JSON parsing with error handling.

The module is particularly useful in microservice architectures where optional dependencies might not be available, in testing environments where certain modules need to be mocked, and in production code where graceful failure is essential.

/**
 * Safe async wrapper utilities for error handling and logging.
 *
 * Eliminates duplication across qerrorsHelpers and shared/errorHandlers by providing
 * a generic wrapper that handles module loading and fallback behavior.
 */
import { loadQerrors } from './qerrorsLoader';
interface SafeWrapperOptions<T extends any[], R> {
  /** Module name to load dynamically */
  moduleName?: string;
  /** Function name to call on the loaded module */
  functionName?: string;
  /** Fallback function to use when module unavailable */
  fallbackFn?: (...args: T) => R | Promise<R>;
  /** Whether to suppress all errors (default: true) */
  silent?: boolean;
  /** Custom log message for errors */
  errorMessage?: string;
}
/**
 * Creates a safe async wrapper that attempts to use a module function
 * and falls back to a console-based alternative when unavailable.
 *
 * @param options - Configuration for the wrapper
 * @returns Async function that safely calls the target function with fallback
 */
export function createSafeAsyncWrapper<T extends any[], R>(
  options: SafeWrapperOptions<T, R>
) {
  const {
    moduleName = 'qerrors',
    functionName = '',
    fallbackFn,
    silent = true,
    errorMessage
  } = options;
  return async function safeWrapper(...args: T): Promise<R | void> {
    try {
      const module = await (moduleName === 'qerrors' ? loadQerrors() : import(moduleName));
      
      if (module && functionName) {
        const fn = typeof module[functionName] === 'function' 
          ? module[functionName] 
          : null;
        
        if (fn) {
          return await fn(...args);
        }
      }
    } catch (error) {
      if (!silent) {
        const message = errorMessage || `Failed to call ${functionName} from ${moduleName}`;
        console.warn(message, error);
      }
    }
    // Fallback function execution
    if (fallbackFn) {
      try {
        return await fallbackFn(...args);
      } catch (fallbackError) {
        if (!silent) {
          console.warn('Fallback function failed:', fallbackError);
        }
      }
    }
  };
}
/**
 * Creates a safe error logger with fallback to console.error.
 *
 * @param functionName - Name of the logging function to use
 * @param fallbackLevel - Console method to use as fallback
 * @returns Safe logging function
 */
export function createSafeLogger(
  functionName: string,
  fallbackLevel: 'error' | 'warn' | 'log' | 'info' = 'error'
) {
  const fallbackFn = (message: string, details?: Record<string, any>) => {
    console[fallbackLevel](message, details);
  };
  return createSafeAsyncWrapper<[string, Record<string, any>?], void>({
    moduleName: 'qerrors',
    functionName,
    fallbackFn,
    errorMessage: `qerrors.${functionName} unavailable, using console.${fallbackLevel}`
  });
}
/**
 * Creates a safe wrapper for any async operation with error handling.
 *
 * @param asyncFn - Async function to wrap
 * @param fallbackValue - Value to return on error
 * @param onError - Optional error handler
 * @returns Wrapped function with try/catch protection
 */
export function createSafeOperation<T extends any[], R>(
  asyncFn: (...args: T) => Promise<R>,
  fallbackValue?: R,
  onError?: (error: unknown, ...args: T) => void
) {
  return async function safeOperation(...args: T): Promise<R | undefined> {
    try {
      return await asyncFn(...args);
    } catch (error) {
      if (onError) {
        onError(error, ...args);
      }
      return fallbackValue;
    }
  };
}
/**
 * Safe async wrapper for JSON parsing with fallback.
 *
 * @param text - String to parse
 * @param fallback - Fallback value when parsing fails
 * @returns Parsed object or fallback value
 */
export function safeJsonParse<T = any>(text: string, fallback: T | null = null): T | null {
  if (typeof text !== 'string') {
    return fallback;
  }
  try {
    return JSON.parse(text);
  } catch {
    return fallback;
  }
}
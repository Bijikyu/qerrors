import { loadQerrors, formatErrorMessage } from './qerrorsCommon.js';
import { executeWithQerrorsCore, type ExecuteWithQerrorsCoreOptions } from './executeWithQerrorsCore.js';

export const executeWithQerrors = async <T>(options: ExecuteWithQerrorsCoreOptions<T>): Promise<T> => 
  executeWithQerrorsCore(options);

export { loadQerrors, formatErrorMessage, ExecuteWithQerrorsCoreOptions };

/**
 * Creates a service-specific executor with standardized naming and error handling
 * Reduces boilerplate in service functions
 */
export const createServiceExecutor = (serviceName: string) => {
  return async <T>({
    operationName,
    operation,
    context = {},
    failureMessage,
    errorCode,
    logMessage
  }: {
    operationName: string;
    operation: () => Promise<T>;
    context?: Record<string, unknown>;
    failureMessage: string;
    errorCode?: string;
    logMessage?: string;
  }) => {
    return await executeWithQerrors<T>({
      opName: `${serviceName}.${operationName}`,
      operation,
      context,
      failureMessage,
      errorCode: errorCode || `${serviceName.toUpperCase()}_${operationName.toUpperCase()}`,
      logMessage: logMessage || `${serviceName} error in ${operationName}`
    });
  };
};

/**
 * Creates a standardized service call pattern for common operations
 */
export const createServiceCall = <T>(
  serviceName: string,
  operationName: string,
  operation: () => Promise<T>,
  options: {
    context?: Record<string, unknown>;
    failureMessage?: string;
    errorCode?: string;
  } = {}
) => {
  return executeWithQerrors<T>({
    opName: `${serviceName}.${operationName}`,
    operation,
    context: options.context,
    failureMessage: options.failureMessage || `${serviceName} ${operationName} failed`,
    errorCode: options.errorCode || `${serviceName.toUpperCase()}_${operationName.toUpperCase()}`,
    logMessage: `${serviceName} error in ${operationName}`
  });
};

/**
 * Creates a batch service executor for multiple related operations
 */
export const createBatchServiceExecutor = (serviceName: string) => {
  return async <T>(
    operations: Array<{
      name: string;
      operation: () => Promise<T>;
      failureMessage?: string;
    }>
  ) => {
    const results = await Promise.allSettled(
      operations.map(({ name, operation, failureMessage }) =>
        createServiceCall(serviceName, name, operation, { failureMessage })
      )
    );

    return results.map((result, index) => ({
      name: operations[index].name,
      success: result.status === 'fulfilled',
      result: result.status === 'fulfilled' ? result.value : null,
      error: result.status === 'rejected' ? result.reason : null
    }));
  };
};
import { qgenutils } from './commonImports.js';
import { loadQerrors, formatErrorMessage, type QerrorsModule, logErrorMaybe } from './qerrorsCommon.js';
import { attempt } from './tryUtils.js';

export interface ExecuteWithQerrorsCoreOptions<T> {
  opName: string;
  operation: () => Promise<T>;
  context?: Record<string, unknown>;
  failureMessage: string;
  errorCode?: string;
  errorType?: string;
  logMessage?: string;
  rethrow?: boolean;
  fallbackValue?: T;
}

export interface ExecuteWithQerrorsHooks {
  augmentContext?: (error: unknown, baseContext: Record<string, unknown>) => Record<string, unknown>;
  formatFailureMessage?: (base: string, error: unknown, context: Record<string, unknown>) => string;
}

export const executeWithQerrorsCore = async <T>(
  options: ExecuteWithQerrorsCoreOptions<T>,
  hooks: ExecuteWithQerrorsHooks = {}
): Promise<T> => {
  const {
    opName,
    operation,
    context = {},
    failureMessage,
    errorCode,
    errorType,
    logMessage = `${opName}failed`,
    rethrow = true,
    fallbackValue
  } = options;

  const fallbackToken = Symbol('qerrorsFallback');
  const qerrors = await loadQerrors();
  let capturedError: unknown = null;

  const guardedOperation = async (): Promise<T> => {
    try {
      return await operation();
    } catch (error) {
      capturedError = error;
      throw error;
    }
  };

  if (qerrors && typeof qerrors.withErrorHandling === 'function') {
    const fallbackSentinel = fallbackToken as unknown as T;
    const fallbackParam = { fallback: fallbackSentinel } as { fallback: T };
    /* Rationale: qerrors.withErrorHandling expects `{ fallback: T }`, passing a non-object causes raw errors to escape. */
    const result = await qerrors.withErrorHandling(guardedOperation, opName, context, fallbackParam);
    if (result !== fallbackSentinel) return result as T;
  } else {
    const outcome = await attempt(guardedOperation);
    if (outcome.ok) return outcome.value as T;
  }

  if (!capturedError) capturedError = new Error('Unknown error');
  const renderedError = formatErrorMessage(capturedError);
  const baseContext = {
    ...context,
    errorMessage: renderedError,
    errorCode
  } as Record<string, unknown>;
  
  const enrichedContext = hooks.augmentContext 
    ? hooks.augmentContext(capturedError, baseContext) 
    : baseContext;
  
  await logErrorMaybe(qerrors, opName, logMessage, enrichedContext);
  
  const baseMessage = `${failureMessage}: ${renderedError}`;
  const finalMessage = hooks.formatFailureMessage 
    ? hooks.formatFailureMessage(baseMessage, capturedError, enrichedContext)
    : baseMessage;
  
let constructedError: Error;
  
  // Use qerrors.createTypedError if available, otherwise create manual error
  if (qerrors && typeof qerrors.createTypedError === 'function') {
    constructedError = qerrors.createTypedError(finalMessage, errorType || 'DEPENDENCY', errorCode || '');
  } else {
    constructedError = new Error(finalMessage);
    (constructedError as any).code = errorCode;
    (constructedError as any).type = errorType || 'DEPENDENCY';
  }
  
  if (fallbackValue !== undefined) {
    return fallbackValue;
  }
  
  if (rethrow) {
    throw constructedError;
  }
  
  return constructedError as unknown as T;
};
Error Handling
@scrooge/response-helpers
Purpose: Standardized Express.js response utilities for consistent API responses across microservices. Explanation:
This module provides a suite of response helper functions that standardize HTTP response formats, success/error handling, and status codes across Express.js applications. It solves the problem of inconsistent response formats across different endpoints and developers, leading to client-side integration issues. This would be reused across any Express.js API project, particularly in microservices architectures where consistent response formats are crucial for client applications.

The module accepts Express response objects, data, messages, and optional configuration objects as inputs, and returns formatted HTTP responses. It handles edge cases like request ID tracking, processing time calculation, validation error formatting, and maintains backward compatibility with existing response patterns.

/**
 * Response Helper Utilities
 * Centralizes qapibara response patterns to eliminate duplication
 * 
 * @author Scrooge Payment System
 */
const qapibara = require('@bijikyu/qapibara');
/**
 * Get typed sendJsonResponse helper to eliminate repeated type casting
 * @returns {Function} Typed sendJsonResponse function
 */
const getSendJsonResponse = () => {
    const { sendJsonResponse } = qapibara;
    return sendJsonResponse;
};
/**
 * Sends JSON response using qapibara
 * @param {Object} res - Express response object
 * @param {number} status - HTTP status code
 * @param {any} data - Response data
 * @returns {Object} Express response
 */
const sendJsonResponse = (res, status, data) => {
  const { sendJsonResponse: qapibaraResponse } = qapibara;
  return qapibaraResponse(res, status, data);
};
/**
 * Sends success response (200) with data
 * @param {Object} res - Express response object
 * @param {any} data - Response data
 * @param {Object} options - Response options
 * @returns {Object} Express response
 */
const sendSuccessResponse = (res, data, options = {}) => {
  const { includeProcessingTime = false, startTime = null } = options;
  
  const responseData = { success: true, data };
  
  if (includeProcessingTime && startTime) {
    responseData.processingTime = Date.now() - startTime;
  }
  
  return sendJsonResponse(res, 200, responseData);
};
/**
 * Sends created response (201) with data
 * @param {Object} res - Express response object
 * @param {any} data - Response data
 * @returns {Object} Express response
 */
const sendCreatedResponse = (res, data) => {
  return sendJsonResponse(res, 201, { success: true, data });
};
/**
 * Sends error response with standard format
 * @param {Object} res - Express response object
 * @param {number} status - HTTP status code
 * @param {string} message - Error message
 * @param {any} details - Error details
 * @param {Object} options - Response options
 * @returns {Object} Express response
 */
const sendErrorResponse = (res, status, message, details = null, options = {}) => {
  const { requestId = null, processingTime = null } = options;
  
  const responseData = { 
    success: false, 
    error: status, 
    message 
  };
  
  if (requestId) responseData.requestId = requestId;
  if (processingTime !== null) responseData.processingTime = processingTime;
  if (details) {
    if (status === 400 && Array.isArray(details)) {
      responseData.errors = details;
    } else {
      responseData.details = details;
    }
  }
  
  return sendJsonResponse(res, status, responseData);
};
/**
 * Sends validation error response (400) with formatted errors
 * @param {Object} res - Express response object
 * @param {Array|string} errors - Validation errors
 * @param {Object} options - Response options
 * @returns {Object} Express response
 */
const sendValidationErrorResponse = (res, errors, options = {}) => {
  const { requestId = null } = options;
  
  return sendErrorResponse(res, 400, 'Validation failed', errors, { requestId });
};
/**
 * Sends not found response (404)
 * @param {Object} res - Express response object
 * @param {string} message - Not found message
 * @returns {Object} Express response
 */
const sendNotFoundResponse = (res, message = 'Resource not found') => {
  return sendErrorResponse(res, 404, message);
};
/**
 * Sends unauthorized response (401)
 * @param {Object} res - Express response object
 * @param {string} message - Unauthorized message
 * @returns {Object} Express response
 */
const sendUnauthorizedResponse = (res, message = 'Unauthorized') => {
  return sendErrorResponse(res, 401, message);
};
/**
 * Sends forbidden response (403)
 * @param {Object} res - Express response object
 * @param {string} message - Forbidden message
 * @returns {Object} Express response
 */
const sendForbiddenResponse = (res, message = 'Forbidden') => {
  return sendErrorResponse(res, 403, message);
};
/**
 * Sends server error response (500)
 * @param {Object} res - Express response object
 * @param {string} message - Server error message
 * @returns {Object} Express response
 */
const sendServerErrorResponse = (res, message = 'Internal server error') => {
  return sendErrorResponse(res, 500, message);
};
/**
 * Creates response helper object with consistent interface
 * @param {Object} res - Express response object
 * @param {number} startTime - Request start time for processing time tracking
 * @returns {Object} Response helper functions
 */
const createResponseHelper = (res, startTime = null) => {
  return {
    success: (data, options = {}) => sendSuccessResponse(res, data, { ...options, startTime }),
    created: (data) => sendCreatedResponse(res, data),
    error: (status, message, details, options = {}) => sendErrorResponse(res, status, message, details, { ...options, startTime }),
    validation: (errors, options = {}) => sendValidationErrorResponse(res, errors, { ...options, startTime }),
    notFound: (message) => sendNotFoundResponse(res, message),
    unauthorized: (message) => sendUnauthorizedResponse(res, message),
    forbidden: (message) => sendForbiddenResponse(res, message),
    serverError: (message) => sendServerErrorResponse(res, message)
  };
};
module.exports = {
  sendJsonResponse,
  sendSuccessResponse,
  sendCreatedResponse,
  sendErrorResponse,
  sendValidationErrorResponse,
  sendNotFoundResponse,
  sendUnauthorizedResponse,
  sendForbiddenResponse,
  sendServerErrorResponse,
  createResponseHelper,
  getSendJsonResponse
};

@scrooge/external-service-circuit-breaker
Purpose: Production-ready circuit breaker pattern implementation for external service resilience and failure protection. Explanation:
This module provides a comprehensive circuit breaker implementation that protects applications from cascading failures when external services become unavailable or slow. It solves the problem of applications becoming unresponsive or crashing due to external service failures by implementing the circuit breaker pattern with configurable thresholds, automatic recovery, and detailed metrics. This would be reused across any microservices architecture where external service calls need protection, particularly in payment processing, external API integrations, and database connections.

The module accepts service operations, service names, and configuration options as inputs, and returns wrapped operations with circuit breaker protection. It handles edge cases like timeout handling, state transitions, metric collection, and provides factory methods for common configurations.

/**
 * External Service Circuit Breaker
 * 
 * Provides circuit breaker pattern for external service calls to prevent
 * cascading failures and improve system resilience under load.
 */
import { qerrors } from './offlineMode/index.js';
interface CircuitBreakerOptions {
  failureThreshold: number;
  recoveryTimeoutMs: number;
  monitoringPeriodMs: number;
  timeoutMs?: number;
}
enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN'
}
interface ServiceMetrics {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
  lastFailureTime?: number;
}
export class ExternalServiceCircuitBreaker<T extends (...args: any[]) => Promise<any>> {
  private state: CircuitState = CircuitState.CLOSED;
  private failureCount = 0;
  private lastFailureTime = 0;
  private metrics: ServiceMetrics = {
    totalRequests: 0,
    successfulRequests: 0,
    failedRequests: 0,
    averageResponseTime: 0
  };
  constructor(
    private operation: T,
    private serviceName: string,
    private options: CircuitBreakerOptions
  ) {
    // Validate options
    if (options.failureThreshold <= 0) {
      throw new Error('failureThreshold must be positive');
    }
    if (options.recoveryTimeoutMs <= 0) {
      throw new Error('recoveryTimeoutMs must be positive');
    }
  }
  /**
   * Execute operation with circuit breaker protection
   */
  async execute(...args: Parameters<T>): Promise<ReturnType<T>> {
    const startTime = Date.now();
    this.metrics.totalRequests++;
    try {
      // Check circuit state before execution
      if (this.state === CircuitState.OPEN) {
        if (this.shouldAttemptReset()) {
          this.state = CircuitState.HALF_OPEN;
          console.log(`[CircuitBreaker] ${this.serviceName}: transitioning to HALF_OPEN`);
        } else {
          throw new Error(`Circuit breaker is OPEN for ${this.serviceName}`);
        }
      }
      // Execute operation with timeout
      const result = await this.executeWithTimeout(...args);
      
      // Record success
      this.recordSuccess(startTime);
      return result;
    } catch (error) {
      // Record failure
      this.recordFailure(startTime, error as Error);
      throw error;
    }
  }
  /**
   * Execute operation with timeout protection
   */
  private async executeWithTimeout(...args: Parameters<T>): Promise<ReturnType<T>> {
    if (!this.options.timeoutMs) {
      return this.operation(...args);
    }
    return Promise.race([
      this.operation(...args),
      new Promise<never>((_, reject) => 
        setTimeout(() => reject(new Error(`Operation timeout after ${this.options.timeoutMs}ms`)), this.options.timeoutMs)
      )
    ]);
  }
  /**
   * Record successful operation
   */
  private recordSuccess(startTime: number): void {
    const responseTime = Date.now() - startTime;
    this.metrics.successfulRequests++;
    
    // Update average response time
    this.metrics.averageResponseTime = 
      (this.metrics.averageResponseTime * (this.metrics.successfulRequests - 1) + responseTime) / 
      this.metrics.successfulRequests;
    // Reset failure count on success
    if (this.state === CircuitState.HALF_OPEN) {
      this.state = CircuitState.CLOSED;
      this.failureCount = 0;
      console.log(`[CircuitBreaker] ${this.serviceName}: transitioning to CLOSED`);
    }
  }
  /**
   * Record failed operation
   */
  private recordFailure(startTime: number, error: Error): void {
    const responseTime = Date.now() - startTime;
    this.metrics.failedRequests++;
    this.metrics.lastFailureTime = startTime;
    this.failureCount++;
    this.lastFailureTime = Date.now();
    // Log error with circuit breaker context
    qerrors(error, `CircuitBreaker-${this.serviceName}`, {
      state: this.state,
      failureCount: this.failureCount,
      responseTime
    });
    // Open circuit if threshold exceeded
    if (this.failureCount >= this.options.failureThreshold && this.state === CircuitState.CLOSED) {
      this.state = CircuitState.OPEN;
      console.warn(`[CircuitBreaker] ${this.serviceName}: transitioning to OPEN after ${this.failureCount} failures`);
    }
    // Keep circuit open if still failing in half-open state
    if (this.state === CircuitState.HALF_OPEN) {
      this.state = CircuitState.OPEN;
      console.warn(`[CircuitBreaker] ${this.serviceName}: returning to OPEN after half-open failure`);
    }
  }
  /**
   * Check if circuit should attempt reset
   */
  private shouldAttemptReset(): boolean {
    return Date.now() - this.lastFailureTime > this.options.recoveryTimeoutMs;
  }
  /**
   * Get current circuit state
   */
  public getState(): CircuitState {
    return this.state;
  }
  /**
   * Get service metrics
   */
  public getMetrics(): ServiceMetrics {
    return { ...this.metrics };
  }
  /**
   * Get success rate
   */
  public getSuccessRate(): number {
    return this.metrics.totalRequests > 0 
      ? this.metrics.successfulRequests / this.metrics.totalRequests 
      : 1;
  }
  /**
   * Get failure rate
   */
  public getFailureRate(): number {
    return this.metrics.totalRequests > 0 
      ? this.metrics.failedRequests / this.metrics.totalRequests 
      : 0;
  }
  /**
   * Reset circuit breaker to closed state
   */
  public reset(): void {
    this.state = CircuitState.CLOSED;
    this.failureCount = 0;
    this.lastFailureTime = 0;
    console.log(`[CircuitBreaker] ${this.serviceName}: manually reset to CLOSED`);
  }
  /**
   * Force circuit open (for testing)
   */
  public forceOpen(): void {
    this.state = CircuitState.OPEN;
    this.failureCount = this.options.failureThreshold;
    this.lastFailureTime = Date.now();
    console.log(`[CircuitBreaker] ${this.serviceName}: forced to OPEN`);
  }
}
// Circuit breaker factory for common configurations
export class CircuitBreakerFactory {
  private static readonly defaultOptions: CircuitBreakerOptions = {
    failureThreshold: 5,
    recoveryTimeoutMs: 60000, // 1 minute
    monitoringPeriodMs: 30000, // 30 seconds
    timeoutMs: 10000 // 10 seconds
  };
  private static readonly aggressiveOptions: CircuitBreakerOptions = {
    failureThreshold: 3,
    recoveryTimeoutMs: 30000, // 30 seconds
    monitoringPeriodMs: 15000, // 15 seconds
    timeoutMs: 5000 // 5 seconds
  };
  private static readonly lenientOptions: CircuitBreakerOptions = {
    failureThreshold: 10,
    recoveryTimeoutMs: 120000, // 2 minutes
    monitoringPeriodMs: 60000, // 1 minute
    timeoutMs: 30000 // 30 seconds
  };
  /**
   * Create circuit breaker with default configuration
   */
  static createDefault<T extends (...args: any[]) => Promise<any>>(
    operation: T,
    serviceName: string
  ): ExternalServiceCircuitBreaker<T> {
    return new ExternalServiceCircuitBreaker(operation, serviceName, this.defaultOptions);
  }
  /**
   * Create circuit breaker with aggressive configuration (for critical services)
   */
  static createAggressive<T extends (...args: any[]) => Promise<any>>(
    operation: T,
    serviceName: string
  ): ExternalServiceCircuitBreaker<T> {
    return new ExternalServiceCircuitBreaker(operation, serviceName, this.aggressiveOptions);
  }
  /**
   * Create circuit breaker with lenient configuration (for non-critical services)
   */
  static createLenient<T extends (...args: any[]) => Promise<any>>(
    operation: T,
    serviceName: string
  ): ExternalServiceCircuitBreaker<T> {
    return new ExternalServiceCircuitBreaker(operation, serviceName, this.lenientOptions);
  }
}
export default ExternalServiceCircuitBreaker;
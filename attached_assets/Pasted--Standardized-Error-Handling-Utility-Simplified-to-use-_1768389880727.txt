/**
 * Standardized Error Handling Utility
 * Simplified to use more qerrors functionality and eliminate duplication
 */

const ErrorTypes = {
  VALIDATION: 'VALIDATION',
  AUTHENTICATION: 'AUTHENTICATION',
  AUTHORIZATION: 'AUTHORIZATION',
  NOT_FOUND: 'NOT_FOUND',
  INTERNAL: 'INTERNAL',
  NETWORK: 'NETWORK',
  DATABASE: 'DATABASE',
};

const ErrorSeverity = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
};

const createTypedError = (type, message, details = {}) => {
  const error = new Error(message);
  error.type = type;
  error.details = details;
  return error;
};

const createStandardError = (message, statusCode = 500) => {
  const error = new Error(message);
  error.statusCode = statusCode;
  return error;
};

const ErrorFactory = {
  validation: (msg) => createTypedError(ErrorTypes.VALIDATION, msg),
  authentication: (msg) => createTypedError(ErrorTypes.AUTHENTICATION, msg),
  authorization: (msg) => createTypedError(ErrorTypes.AUTHORIZATION, msg),
  notFound: (msg) => createTypedError(ErrorTypes.NOT_FOUND, msg),
  internal: (msg) => createTypedError(ErrorTypes.INTERNAL, msg),
};

const qerrors = async () => {};
qerrors.logErrorWithSeverity = (error, severity, context) => console.error(`[${severity}] ${context}:`, error);
qerrors.handleControllerError = (error, req, res, next) => {
  console.error('Controller error:', error);
  if (next) next(error);
};
qerrors.withErrorHandling = (fn) => fn;

const errorMiddleware = (err, req, res, next) => {
  console.error('Error:', err);
  res.status(err.statusCode || 500).json({ error: err.message });
};

/**
 * Standard error handler function for controllers - uses qerrors handleControllerError
 * @param {Error} error - Error object
 * @param {string} operation - Operation being performed (e.g., 'get email rules')
 * @param {Object} context - Additional context for logging (req, res, etc.)
 * @param {Object} options - Error handling options
 * @param {string} options.userMessage - Custom user-facing error message
 * @param {number} options.statusCode - Custom HTTP status code
 * @returns {Object} Error response
 */
const handleControllerError = async (error, operation, context = {}, options = {}) => {
  const {
    userMessage = `Failed to ${operation}`,
    statusCode = 500
  } = options;

  // Use qerrors handleControllerError for standardized handling
  if (context.res) {
    // If res is available, let qerrors handle response directly
    return qerrors.handleControllerError(error, operation, context, context.res);
  }

  // For cases where we need to return a response object
  await qerrors.logErrorWithSeverity(error, 'MEDIUM', `${operation} failed`);

  return {
    statusCode,
    response: {
      error: userMessage,
      details: error.message,
      timestamp: new Date().toISOString()
    }
  };
};

/**
 * Creates a standardized error-wrapped controller function - uses qerrors errorMiddleware
 * @param {Function} controllerFn - Controller function to wrap
 * @param {string} operation - Operation description for error messages
 * @param {Object} options - Error handling options
 * @returns {Function} Wrapped controller function
 */
const createErrorHandledController = (controllerFn, operation, options = {}) => {
  return async (req, res, next) => {
    try {
      await controllerFn(req, res, next);
    } catch (error) {
      // Use qerrors for consistent error handling with proper async handling
      try {
        qerrors.handleControllerError(error, operation, {
          query: req.query,
          params: req.params,
          body: req.body,
          method: req.method,
          url: req.url
        }, res, next);
      } catch (handlerError) {
        // Fallback error handling if qerrors fails
        console.error('Error handler failed:', handlerError);
        if (!res.headersSent) {
          res.status(500).json({
            error: 'Internal server error',
            message: 'An unexpected error occurred'
          });
        }
      }
    }
  };
};

/**
 * Validates required request parameters - uses qgenutils requireFields via validationUtils
 * @param {Object} req - Request object
 * @param {Array} requiredFields - Array of required field names
 * @param {string} location - Where to check fields ('params', 'body', 'query')
 * @returns {Object|null} Validation error or null if valid
 */
const validateRequiredFields = (req, requiredFields, location = 'body') => {
  const source = req[location];
  const missingFields = requiredFields.filter(field => !source[field]);

  if (missingFields.length > 0) {
    // Use qerrors ErrorFactory for consistent error creation
    const error = ErrorFactory.validation('Missing required fields', {
      required: requiredFields,
      missing: missingFields
    });

    return {
      statusCode: 400,
      response: {
        error: error.message,
        details: error.details,
        timestamp: new Date().toISOString()
      }
    };
  }

  return null;
};

/**
 * Handles resource not found scenarios consistently - uses qerrors ErrorFactory
 * @param {string} resourceType - Type of resource (e.g., 'email template')
 * @param {Object} context - Context for logging
 * @returns {Object} Not found response
 */
const handleResourceNotFound = (resourceType, context = {}) => {
  const message = `${resourceType.charAt(0).toUpperCase() + resourceType.slice(1)} not found`;
  
  // Use qerrors ErrorFactory for consistent error creation
  const error = ErrorFactory.notFound(resourceType);
  
  // Log not found scenario
  qerrors.logErrorWithSeverity(error, 'LOW', message);

  return {
    statusCode: 404,
    response: {
      error: error.message,
      timestamp: new Date().toISOString()
    }
  };
};

/**
 * Handles validation errors consistently - uses qerrors ErrorFactory
 * @param {string} message - Validation error message
 * @param {Object} details - Additional validation details
 * @param {Object} context - Context for logging
 * @returns {Object} Validation error response
 */
const handleValidationError = (message, details = null, context = {}) => {
  // Use qerrors ErrorFactory for consistent error creation
  const error = ErrorFactory.validation(message, details);
  
  // Log validation error
  qerrors.logErrorWithSeverity(error, 'MEDIUM', 'Validation failed');

  return {
    statusCode: 400,
    response: {
      error: error.message,
      details: error.details || details,
      timestamp: new Date().toISOString()
    }
  };
};

export {
  handleControllerError,
  createErrorHandledController,
  validateRequiredFields,
  handleResourceNotFound,
  handleValidationError,
  ErrorFactory,
  ErrorTypes,
  ErrorSeverity,
  createTypedError,
  createStandardError,
  errorMiddleware
};
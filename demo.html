<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QErrors Module - Functional Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.5em;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            background: rgba(102, 126, 234, 0.1);
            padding: 10px 20px;
            border-radius: 25px;
            border: 2px solid #667eea;
            font-weight: 500;
        }

        .status-item.active {
            background: #667eea;
            color: white;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }

        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .response-area {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .response-area pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
        }

        .error-response {
            border-color: #f5c6cb;
            background: #fff5f5;
        }

        .success-response {
            border-color: #c3e6cb;
            background: #f5fff5;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(102, 126, 234, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #667eea;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .metric-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid;
        }

        .alert-info {
            background: #d1ecf1;
            border-color: #0c5460;
            color: #0c5460;
        }

        .alert-warning {
            background: #fff3cd;
            border-color: #856404;
            color: #856404;
        }

        .alert-error {
            background: #f8d7da;
            border-color: #721c24;
            color: #721c24;
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .feature-list {
            list-style: none;
            padding: 0;
        }

        .feature-list li {
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .feature-list li:last-child {
            border-bottom: none;
        }

        .check-icon {
            color: #28a745;
            font-weight: bold;
        }

        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(26px);
        }

        
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                <div class="logo">Q</div>
                QErrors Module - Functional Demo
            </h1>
            <p class="subtitle">Intelligent Error Handling Middleware with AI-Powered Analysis</p>
            <div class="status-bar">
                <div class="status-item active" id="server-status">Server: Connected</div>
                <div class="status-item" id="ai-status">AI: Ready</div>
                <div class="status-item" id="cache-status">Cache: Active</div>
                <div class="status-item" id="queue-status">Queue: Empty</div>
            </div>
        </header>

        <div class="main-content">
            <div class="card">
                <h2>üß™ Error Testing</h2>
                
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('basic-errors')">Basic Errors</button>
                    <button class="tab" onclick="switchTab('custom-errors')">Custom Errors</button>
                    <button class="tab" onclick="switchTab('ai-analysis')">AI Analysis</button>
                </div>

                <div id="basic-errors" class="tab-content active">
                    <div class="form-group">
                        <label for="error-type">Error Type</label>
                        <select id="error-type">
                            <option value="validation">Validation Error</option>
                            <option value="authentication">Authentication Error</option>
                            <option value="authorization">Authorization Error</option>
                            <option value="network">Network Error</option>
                            <option value="system">System Error</option>
                            <option value="database">Database Error</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="error-message">Error Message</label>
                        <input type="text" id="error-message" placeholder="Enter custom error message" value="Test error message">
                    </div>

                    <div class="form-group">
                        <label for="error-context">Context (JSON)</label>
                        <textarea id="error-context" placeholder='{"userId": "123", "action": "create"}'>{"userId": "123", "action": "create"}</textarea>
                    </div>

                    <div class="btn-group">
                        <button class="btn" onclick="triggerError()">
                            ‚ö° Trigger Error
                        </button>
                        <button class="btn btn-danger" onclick="triggerCriticalError()">
                            üö® Critical Error
                        </button>
                        <button class="btn btn-secondary" onclick="clearResponse()">
                            üóëÔ∏è Clear
                        </button>
                    </div>
                </div>

                <div id="custom-errors" class="tab-content">
                    <div class="form-group">
                        <label for="custom-error-name">Error Name</label>
                        <input type="text" id="custom-error-name" placeholder="CustomErrorName" value="CustomBusinessError">
                    </div>

                    <div class="form-group">
                        <label for="custom-error-code">Error Code</label>
                        <input type="text" id="custom-error-code" placeholder="BUSINESS_RULE_VIOLATION" value="BUSINESS_RULE_VIOLATION">
                    </div>

                    <div class="form-group">
                        <label for="custom-error-severity">Severity</label>
                        <select id="custom-error-severity">
                            <option value="low">Low</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High</option>
                            <option value="critical">Critical</option>
                        </select>
                    </div>

                    <div class="btn-group">
                        <button class="btn" onclick="triggerCustomError()">
                            üéØ Trigger Custom Error
                        </button>
                        <button class="btn btn-success" onclick="testErrorRecovery()">
                            üîÑ Test Recovery
                        </button>
                    </div>
                </div>

                <div id="ai-analysis" class="tab-content">
                    <div class="form-group">
                        <label for="ai-scenario">AI Analysis Scenario</label>
                        <select id="ai-scenario">
                            <option value="database-connection">Database Connection Failed</option>
                            <option value="api-timeout">External API Timeout</option>
                            <option value="memory-leak">Memory Leak Detected</option>
                            <option value="race-condition">Race Condition</option>
                            <option value="file-permission">File Permission Error</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="ai-provider">AI Provider</label>
                        <select id="ai-provider">
                            <option value="openai">OpenAI GPT</option>
                            <option value="google">Google Gemini</option>
                            <option value="anthropic">Anthropic Claude</option>
                        </select>
                    </div>

                    <div class="btn-group">
                        <button class="btn" onclick="triggerAIAnalysis()">
                            ü§ñ Analyze with AI
                        </button>
                        <button class="btn btn-secondary" onclick="testAIHealth()">
                            üíâ AI Health Check
                        </button>
                    </div>
                </div>

                <div class="response-area" id="error-response">
                    <pre>Response will appear here...</pre>
                </div>
            </div>

            <div class="card">
                <h2>üìä System Metrics</h2>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="total-errors">0</div>
                        <div class="metric-label">Total Errors</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="queue-length">0</div>
                        <div class="metric-label">Queue Length</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="cache-hits">0</div>
                        <div class="metric-label">Cache Hits</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="ai-requests">0</div>
                        <div class="metric-label">AI Requests</div>
                    </div>
                </div>

                <h3>Configuration</h3>
                <div class="config-section">
                    <div class="config-grid">
                        <div class="config-item">
                            <span>AI Analysis</span>
                            <div class="toggle-switch active" id="ai-toggle" onclick="toggleConfig('ai')"></div>
                        </div>
                        <div class="config-item">
                            <span>Caching</span>
                            <div class="toggle-switch active" id="cache-toggle" onclick="toggleConfig('cache')"></div>
                        </div>
                        <div class="config-item">
                            <span>Queue Metrics</span>
                            <div class="toggle-switch active" id="metrics-toggle" onclick="toggleConfig('metrics')"></div>
                        </div>
                        <div class="config-item">
                            <span>Verbose Logging</span>
                            <div class="toggle-switch" id="verbose-toggle" onclick="toggleConfig('verbose')"></div>
                        </div>
                    </div>
                </div>

                <h3>Environment</h3>
                <div class="config-section">
                    <div class="config-grid">
                        <div class="config-item">
                            <span>Node Environment</span>
                            <span id="node-env">development</span>
                        </div>
                        <div class="config-item">
                            <span>Log Level</span>
                            <span id="log-level">info</span>
                        </div>
                        <div class="config-item">
                            <span>Cache TTL</span>
                            <span id="cache-ttl">24h</span>
                        </div>
                        <div class="config-item">
                            <span>Queue Limit</span>
                            <span id="queue-limit">100</span>
                        </div>
                    </div>
                </div>

                <h3>Actions</h3>
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="clearCache()">
                        üóëÔ∏è Clear Cache
                    </button>
                    <button class="btn btn-secondary" onclick="resetMetrics()">
                        üìä Reset Metrics
                    </button>
                    <button class="btn btn-success" onclick="exportLogs()">
                        üì• Export Logs
                    </button>
                </div>
            </div>
        </div>

        

        

        

        

        

        

        

        

        <div class="card">
            <h2>üöÄ Features & Capabilities</h2>
            <ul class="feature-list">
                <li><span class="check-icon">‚úì</span> AI-powered error analysis with multiple provider support</li>
                <li><span class="check-icon">‚úì</span> Intelligent caching system for cost optimization</li>
                <li><span class="check-icon">‚úì</span> Queue-based async processing with rate limiting</li>
                <li><span class="check-icon">‚úì</span> Comprehensive error typing and severity levels</li>
                <li><span class="check-icon">‚úì</span> Express middleware integration</li>
                <li><span class="check-icon">‚úì</span> Winston-based logging with daily rotation</li>
                <li><span class="check-icon">‚úì</span> Circuit breaker pattern for resilience</li>
                <li><span class="check-icon">‚úì</span> Environment variable validation</li>
                <li><span class="check-icon">‚úì</span> Performance monitoring and metrics</li>
                <li><span class="check-icon">‚úì</span> Content sanitization for security</li>
                <li><span class="check-icon">‚úì</span> Graceful degradation and error-safe design</li>
                <li><span class="check-icon">‚úì</span> TypeScript support with type definitions</li>
            </ul>
        </div>

        <div class="card">
            <h2>üìù API Endpoints Tested</h2>
            <div class="alert alert-info">
                <strong>Note:</strong> This demo tests the qerrors module functionality through simulated API calls. 
                In a real application, these would be actual Express middleware integrations.
            </div>
            <ul class="feature-list">
                <li><code>POST /api/errors/trigger</code> - Triggers various error types</li>
                <li><code>POST /api/errors/custom</code> - Creates custom business errors</li>
                <li><code>POST /api/errors/analyze</code> - AI-powered error analysis</li>
                <li><code>GET /api/metrics</code> - System performance metrics</li>
                <li><code>POST /api/config</code> - Dynamic configuration updates</li>
                <li><code>GET /api/health</code> - AI model health checks</li>
                <li><code>DELETE /api/cache</code> - Cache management operations</li>
                <li><code>GET /api/logs/export</code> - Log export functionality</li>
            </ul>
        </div>

        <div class="card">
            <h2>üß™ Advanced Testing Scenarios</h2>
            <div class="tabs">
                <button class="tab active" onclick="switchAdvancedTab('circuit-breaker')">Circuit Breaker</button>
                <button class="tab" onclick="switchAdvancedTab('queue-stress')">Queue Stress</button>
                <button class="tab" onclick="switchAdvancedTab('cache-performance')">Cache Performance</button>
                <button class="tab" onclick="switchAdvancedTab('ai-fallback')">AI Fallback</button>
            </div>

            <div id="circuit-breaker" class="tab-content active">
                <div class="form-group">
                    <label for="circuitThreshold">Failure Threshold:</label>
                    <input type="number" id="circuitThreshold" value="5" min="1" max="10">
                </div>
                <div class="form-group">
                    <label for="circuitTimeout">Timeout (ms):</label>
                    <input type="number" id="circuitTimeout" value="30000" min="1000" max="120000">
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="testCircuitBreaker()">Test Circuit Breaker</button>
                    <button class="btn btn-danger" onclick="forceCircuitOpen()">Force Open</button>
                    <button class="btn btn-success" onclick="resetCircuit()">Reset Circuit</button>
                </div>
            </div>

            <div id="queue-stress" class="tab-content">
                <div class="form-group">
                    <label for="stressConcurrency">Concurrent Requests:</label>
                    <input type="number" id="stressConcurrency" value="50" min="10" max="200">
                </div>
                <div class="form-group">
                    <label for="stressDuration">Duration (seconds):</label>
                    <input type="number" id="stressDuration" value="10" min="5" max="60">
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="startStressTest()">Start Stress Test</button>
                    <button class="btn btn-secondary" onclick="stopStressTest()">Stop Test</button>
                </div>
            </div>

            <div id="cache-performance" class="tab-content">
                <div class="form-group">
                    <label for="cacheSize">Cache Size:</label>
                    <input type="number" id="cacheSize" value="1000" min="100" max="10000">
                </div>
                <div class="form-group">
                    <label for="cacheTTL">TTL (seconds):</label>
                    <input type="number" id="cacheTTL" value="3600" min="60" max="86400">
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="benchmarkCache()">Benchmark Cache</button>
                    <button class="btn btn-secondary" onclick="testCacheEviction()">Test Eviction</button>
                </div>
            </div>

            <div id="ai-fallback" class="tab-content">
                <div class="form-group">
                    <label for="primaryAI">Primary AI Provider:</label>
                    <select id="primaryAI">
                        <option value="openai">OpenAI</option>
                        <option value="google">Google</option>
                        <option value="anthropic">Anthropic</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="fallbackAI">Fallback AI Provider:</label>
                    <select id="fallbackAI">
                        <option value="google">Google</option>
                        <option value="openai">OpenAI</option>
                        <option value="anthropic">Anthropic</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="testAIFallback()">Test AI Fallback</button>
                    <button class="btn btn-danger" onclick="simulateAIOutage()">Simulate Outage</button>
                </div>
            </div>

            <div class="response-area" id="advanced-response">
                <pre>Advanced test results will appear here...</pre>
            </div>
        </div>
    </div>
    </div>

    

    <script>
        // Global state
        let metrics = {
            totalErrors: 0,
            queueLength: 0,
            cacheHits: 0,
            aiRequests: 0
        };

        let config = {
            ai: true,
            cache: true,
            metrics: true,
            verbose: false
        };



        // Tab switching
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }

        // Advanced tab switching
        function switchAdvancedTab(tabId, event) {
            const advancedTabs = document.querySelectorAll('#circuit-breaker, #queue-stress, #cache-performance, #ai-fallback');
            const advancedTabButtons = document.querySelectorAll('.card:nth-child(3) .tab');
            
            advancedTabButtons.forEach(tab => tab.classList.remove('active'));
            advancedTabs.forEach(content => content.classList.remove('active'));
            
            // Fix: Use event parameter instead of undefined global event
            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(tabId).classList.add('active');
        }

        // Advanced testing functions
        function testCircuitBreaker() {
            const thresholdElement = document.getElementById('circuitThreshold');
            const timeoutElement = document.getElementById('circuitTimeout');
            
            if (!thresholdElement || !timeoutElement) {
                console.error('Circuit breaker elements not found');
                return;
            }
            
            const threshold = parseInt(thresholdElement.value) || 5;
            const timeout = parseInt(timeoutElement.value) || 60000;
            
            updateResponse('advanced-response', 'Testing circuit breaker...', 'loading');
            
            setTimeout(() => {
                const circuitTest = {
                    config: { threshold, timeout },
                    test: {
                        totalRequests: 20,
                        failures: 8,
                        successes: 12,
                        state: 'OPEN',
                        reason: 'Failure threshold exceeded'
                    },
                    metrics: {
                        failureRate: '40%',
                        responseTime: '2.3s',
                        lastFailure: new Date().toISOString()
                    },
                    behavior: {
                        currentState: 'OPEN',
                        nextState: 'HALF_OPEN',
                        recoveryTime: timeout + 'ms'
                    }
                };
                
                updateResponse('advanced-response', 'Circuit Breaker Test:\n' + JSON.stringify(circuitTest, null, 2), 'error');
            }, 1500);
        }

        function forceCircuitOpen() {
            updateResponse('advanced-response', 'Forcing circuit open...', 'loading');
            
            setTimeout(() => {
                const forcedOpen = {
                    action: 'force_open',
                    state: 'OPEN',
                    reason: 'Manual intervention',
                    timestamp: new Date().toISOString(),
                    nextRecoveryAttempt: new Date(Date.now() + 30000).toISOString()
                };
                
                updateResponse('advanced-response', 'Circuit Forced Open:\n' + JSON.stringify(forcedOpen, null, 2), 'warning');
            }, 500);
        }

        function resetCircuit() {
            updateResponse('advanced-response', 'Resetting circuit breaker...', 'loading');
            
            setTimeout(() => {
                const reset = {
                    action: 'reset',
                    previousState: 'OPEN',
                    newState: 'CLOSED',
                    timestamp: new Date().toISOString(),
                    metrics: {
                        totalResets: 3,
                        lastResetDuration: '45s',
                        uptime: '87%'
                    }
                };
                
                updateResponse('advanced-response', 'Circuit Reset:\n' + JSON.stringify(reset, null, 2), 'success');
            }, 1000);
        }

        function startStressTest() {
            const concurrencyElement = document.getElementById('stressConcurrency');
            const durationElement = document.getElementById('stressDuration');
            
            if (!concurrencyElement || !durationElement) {
                console.error('Stress test elements not found');
                return;
            }
            
            const concurrency = parseInt(concurrencyElement.value) || 100;
            const duration = parseInt(durationElement.value) || 30000;
            
            updateResponse('advanced-response', `Starting stress test: ${concurrency} concurrent requests for ${duration}s...`, 'loading');
            
            let progress = 0;
            const interval = setInterval(() => {
                progress += 10;
                
                if (progress >= 100) {
                    clearInterval(interval);
                    
                    const stressResults = {
                        test: 'queue_stress_test',
                        config: { concurrency, duration },
                        results: {
                            totalRequests: concurrency * duration,
                            successfulRequests: Math.floor(concurrency * duration * 0.85),
                            failedRequests: Math.floor(concurrency * duration * 0.15),
                            averageResponseTime: '234ms',
                            peakQueueLength: Math.floor(concurrency * 0.3),
                            queueRejections: Math.floor(concurrency * 0.05)
                        },
                        performance: {
                            throughput: `${Math.floor(concurrency * 0.85)} req/sec`,
                            errorRate: '15%',
                            memoryUsage: '125MB',
                            cpuUsage: '45%'
                        }
                    };
                    
                    updateResponse('advanced-response', 'Stress Test Results:\n' + JSON.stringify(stressResults, null, 2), 'success');
                } else {
                    updateResponse('advanced-response', `Stress test in progress: ${progress}% complete...`, 'loading');
                }
            }, duration * 100);
        }

        function stopStressTest() {
            updateResponse('advanced-response', 'Stress test stopped by user', 'warning');
        }

        function benchmarkCache() {
            const sizeElement = document.getElementById('cacheSize');
            const ttlElement = document.getElementById('cacheTTL');
            
            if (!sizeElement || !ttlElement) {
                console.error('Cache configuration elements not found');
                return;
            }
            
            const size = parseInt(sizeElement.value) || 100;
            const ttl = parseInt(ttlElement.value) || 3600;
            
            updateResponse('advanced-response', 'Running cache benchmark...', 'loading');
            
            setTimeout(() => {
                const benchmark = {
                    config: { size, ttl },
                    operations: {
                        writes: 10000,
                        reads: 50000,
                        updates: 2000,
                        deletes: 1000
                    },
                    performance: {
                        avgWriteTime: '0.23ms',
                        avgReadTime: '0.12ms',
                        avgUpdateTime: '0.31ms',
                        avgDeleteTime: '0.18ms'
                    },
                    efficiency: {
                        hitRate: '94.2%',
                        missRate: '5.8%',
                        evictionRate: '2.1%',
                        memoryUsage: `${Math.floor(size * 0.156)}MB`
                    },
                    distribution: {
                        hotKeys: '12%',
                        coldKeys: '88%',
                        fragmentation: '3.2%'
                    }
                };
                
                updateResponse('advanced-response', 'Cache Benchmark:\n' + JSON.stringify(benchmark, null, 2), 'success');
            }, 2000);
        }

        function testCacheEviction() {
            updateResponse('advanced-response', 'Testing cache eviction policies...', 'loading');
            
            setTimeout(() => {
                const evictionTest = {
                    policy: 'LRU',
                    test: {
                        cacheSize: 1000,
                        itemsInserted: 1500,
                        itemsEvicted: 500,
                        evictionTime: '1.2ms'
                    },
                    evictedItems: [
                        { key: 'item_001', age: '45s', accessCount: 2 },
                        { key: 'item_002', age: '1m 12s', accessCount: 1 },
                        { key: 'item_003', age: '2m 34s', accessCount: 0 }
                    ],
                    metrics: {
                        evictionRate: '33.3%',
                        avgItemAge: '1m 45s',
                        memoryRecovered: '78MB'
                    }
                };
                
                updateResponse('advanced-response', 'Cache Eviction Test:\n' + JSON.stringify(evictionTest, null, 2), 'success');
            }, 1500);
        }

        function testAIFallback() {
            const primaryElement = document.getElementById('primaryAI');
            const fallbackElement = document.getElementById('fallbackAI');
            
            if (!primaryElement || !fallbackElement) {
                console.error('AI model elements not found');
                return;
            }
            
            const primary = primaryElement.value || 'openai';
            const fallback = fallbackElement.value || 'google';
            
            updateResponse('advanced-response', `Testing AI fallback: ${primary} ‚Üí ${fallback}...`, 'loading');
            
            setTimeout(() => {
                const fallbackTest = {
                    primary: { provider: primary, status: 'failed', error: 'Rate limit exceeded' },
                    fallback: { provider: fallback, status: 'success', latency: '1.8s' },
                    analysis: {
                        confidence: 87,
                        suggestions: [
                            'Implement rate limiting for primary provider',
                            'Configure automatic fallback on errors',
                            'Monitor provider health continuously'
                        ]
                    },
                    cost: {
                        primary: '$0.00 (failed)',
                        fallback: '$0.0234',
                        total: '$0.0234'
                    }
                };
                
                updateResponse('advanced-response', 'AI Fallback Test:\n' + JSON.stringify(fallbackTest, null, 2), 'success');
            }, 2500);
        }

        function simulateAIOutage() {
            updateResponse('advanced-response', 'Simulating AI provider outage...', 'loading');
            
            setTimeout(() => {
                const outage = {
                    scenario: 'ai_provider_outage',
                    affectedProviders: ['openai', 'google'],
                    availableProviders: ['anthropic'],
                    fallbackActivated: true,
                    degradation: {
                        responseTime: '+300%',
                        accuracy: '-15%',
                        availability: '100%'
                    },
                    recovery: {
                        estimatedTime: '15 minutes',
                        automaticRecovery: true,
                        notifications: ['slack', 'email', 'pagerduty']
                    }
                };
                
                updateResponse('advanced-response', 'AI Outage Simulation:\n' + JSON.stringify(outage, null, 2), 'error');
            }, 1000);
        }

        // Error triggering functions
        async function triggerError() {
            const errorTypeElement = document.getElementById('error-type');
            const messageElement = document.getElementById('error-message');
            
            if (!errorTypeElement || !messageElement) {
                console.error('Error test elements not found');
                return;
            }
            
            const errorType = errorTypeElement.value || 'ValidationError';
            const message = messageElement.value || 'Test error message';
            const contextStr = document.getElementById('error-context').value;
            
            let context;
            try {
                context = JSON.parse(contextStr);
            } catch (e) {
                context = { parseError: e.message };
            }

            updateResponse('error-response', 'Processing error...', 'loading');
            
            try {
                const response = await fetch('/api/errors/trigger', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        type: errorType.toLowerCase(), 
                        message, 
                        context 
                    })
                });
                
                const data = await response.json();
                metrics.totalErrors++;
                updateResponse('error-response', JSON.stringify(data, null, 2), 'success');
                updateMetrics();
            } catch (error) {
                // Fallback to mock response if backend is unavailable
                console.warn('Backend unavailable, using fallback:', error.message);
                
                const errorData = {
                    type: errorType,
                    message: message,
                    context: context,
                    timestamp: new Date().toISOString(),
                    severity: getSeverityForType(errorType)
                };
                
                metrics.totalErrors++;
                metrics.queueLength = Math.max(0, metrics.queueLength - 1);
                
                const fallbackResponse = {
                    success: true,
                    errorId: generateErrorId(),
                    error: errorData,
                    aiAdvice: config.ai ? generateAIAdvice(errorType) : null,
                    cached: config.cache && Math.random() > 0.7,
                    fallback: true
                };
                
                if (fallbackResponse.cached) metrics.cacheHits++;
                if (config.ai) metrics.aiRequests++;
                
                updateResponse('error-response', JSON.stringify(fallbackResponse, null, 2), 'success');
                updateMetrics();
            }
        }

        async function triggerCriticalError() {
            const criticalError = {
                type: 'system',
                message: 'Critical system failure detected',
                context: {
                    severity: 'critical',
                    systemState: 'degraded',
                    affectedServices: ['database', 'cache', 'queue']
                },
                timestamp: new Date().toISOString(),
                severity: 'critical'
            };

            updateResponse('error-response', 'Processing critical error...', 'error');
            
            setTimeout(() => {
                metrics.totalErrors += 5;
                metrics.queueLength += 3;
                
                const response = {
                    success: false,
                    errorId: generateErrorId(),
                    error: criticalError,
                    aiAdvice: config.ai ? {
                        level: 'critical',
                        immediate: 'Restart affected services immediately',
                        investigation: 'Check system logs for root cause',
                        prevention: 'Implement circuit breakers and health checks'
                    } : null,
                    escalation: 'CRITICAL',
                    notificationSent: true
                };
                
                updateResponse('error-response', JSON.stringify(response, null, 2), 'error');
                updateMetrics();
                updateStatus('critical');
            }, 1500);
        }

async function triggerCustomError() {
            const name = document.getElementById('custom-error-name').value;
            const code = document.getElementById('custom-error-code').value;
            const severity = document.getElementById('custom-error-severity').value;

            updateResponse('error-response', 'Processing custom error...', 'loading');
            
            try {
                const response = await fetch('/api/errors/custom', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name, 
                        code, 
                        message: `Custom business error: ${code}`,
                        severity,
                        context: {
                            businessRule: 'Custom validation failed',
                            department: 'engineering',
                            impact: 'medium'
                        }
                    })
                });
                
                const data = await response.json();
                metrics.totalErrors++;
                updateResponse('error-response', JSON.stringify(data, null, 2), 'success');
                updateMetrics();
            } catch (error) {
                // Fallback to mock response if backend is unavailable
                console.warn('Backend unavailable, using fallback:', error.message);
                
                const customError = {
                    name: name,
                    code: code,
                    message: `Custom business error: ${code}`,
                    type: 'business',
                    severity: severity,
                    context: {
                        businessRule: 'Custom validation failed',
                        department: 'engineering',
                        impact: 'medium'
                    },
                    timestamp: new Date().toISOString()
                };
                
                metrics.totalErrors++;
                
                const fallbackResponse = {
                    success: true,
                    errorId: generateErrorId(),
                    error: customError,
                    workflow: 'custom_error_handler',
                    businessLogic: 'Applied custom business rules',
                    recovery: 'Error handled by custom middleware',
                    fallback: true
                };
                
                updateResponse('error-response', JSON.stringify(fallbackResponse, null, 2), 'success');
                updateMetrics();
            }
        }

        async function testErrorRecovery() {
            updateResponse('error-response', 'Testing error recovery mechanisms...', 'loading');
            
            setTimeout(() => {
                const recoveryTest = {
                    scenario: 'error_recovery_test',
                    tests: [
                        { name: 'Circuit Breaker', status: 'PASS', response: 'Circuit opened successfully' },
                        { name: 'Retry Logic', status: 'PASS', response: '3 retries attempted, failed gracefully' },
                        { name: 'Fallback Response', status: 'PASS', response: 'Fallback data provided' },
                        { name: 'Queue Recovery', status: 'PASS', response: 'Queue processed after recovery' }
                    ],
                    overall: 'PASS',
                    recommendation: 'All recovery mechanisms working correctly'
                };
                
                updateResponse('error-response', JSON.stringify(recoveryTest, null, 2), 'success');
            }, 2000);
        }

        async function triggerAIAnalysis() {
            const scenario = document.getElementById('ai-scenario').value;
            const provider = document.getElementById('ai-provider').value;

            updateResponse('error-response', `Analyzing with ${provider} AI...`, 'loading');
            
            try {
                const response = await fetch('/api/errors/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        error: { 
                            message: `Test error for ${scenario} analysis`,
                            name: 'AnalysisTestError',
                            stack: new Error().stack
                        }, 
                        context: { scenario, provider } 
                    })
                });
                
                const data = await response.json();
                metrics.aiRequests++;
                updateResponse('error-response', JSON.stringify(data, null, 2), 'success');
                updateMetrics();
            } catch (error) {
                // Fallback to mock response if backend is unavailable
                console.warn('Backend unavailable, using fallback:', error.message);
                
                metrics.aiRequests++;
                
                const fallbackAnalysis = {
                    provider: provider,
                    scenario: scenario,
                    analysis: generateScenarioAnalysis(scenario),
                    confidence: Math.floor(Math.random() * 20) + 80,
                    processingTime: Math.floor(Math.random() * 1000) + 500,
                    cost: `$${(Math.random() * 0.05 + 0.01).toFixed(4)}`,
                    fallback: true
                };
                
                updateResponse('error-response', JSON.stringify(fallbackAnalysis, null, 2), 'success');
                updateMetrics();
            }
        }

        async function testAIHealth() {
            updateResponse('error-response', 'Checking AI model health...', 'loading');
            
            setTimeout(() => {
                const healthCheck = {
                    status: 'healthy',
                    models: {
                        openai: { status: 'healthy', latency: '234ms', lastCheck: new Date().toISOString() },
                        google: { status: 'healthy', latency: '189ms', lastCheck: new Date().toISOString() },
                        anthropic: { status: 'degraded', latency: '1200ms', lastCheck: new Date().toISOString() }
                    },
                    recommendations: [
                        'Anthropic model showing high latency, consider fallback',
                        'All other models performing within acceptable ranges'
                    ]
                };
                
                updateResponse('error-response', JSON.stringify(healthCheck, null, 2), 'success');
            }, 1500);
        }

        // Configuration functions
        function toggleConfig(configName) {
            config[configName] = !config[configName];
            const toggle = document.getElementById(`${configName}-toggle`);
            toggle.classList.toggle('active');
            
            // Show feedback
            const status = config[configName] ? 'enabled' : 'disabled';
            showNotification(`${configName.toUpperCase()} ${status}`, 'info');
        }

        function clearCache() {
            metrics.cacheHits = 0;
            showNotification('Cache cleared successfully', 'success');
            updateMetrics();
        }

        function resetMetrics() {
            metrics = {
                totalErrors: 0,
                queueLength: 0,
                cacheHits: 0,
                aiRequests: 0
            };
            showNotification('Metrics reset successfully', 'success');
            updateMetrics();
        }

        async function exportLogs() {
            try {
                const response = await fetch('/api/logs/export');
                const serverLogs = await response.json();
                
                const logs = {
                    timestamp: new Date().toISOString(),
                    serverLogs: serverLogs.logs,
                    metrics: metrics,
                    config: config,
                    demoSession: {
                        duration: '5 minutes',
                        errorsTested: metrics.totalErrors,
                        aiRequests: metrics.aiRequests
                    }
                };
                
                const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'qerrors-demo-logs.json';
                a.click();
            } catch (error) {
                // Fallback to local logs
                const logs = {
                    timestamp: new Date().toISOString(),
                    error: 'Failed to fetch server logs',
                    metrics: metrics,
                    config: config,
                    demoSession: {
                        duration: '5 minutes',
                        errorsTested: metrics.totalErrors,
                        aiRequests: metrics.aiRequests
                    }
                };
                
                const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'qerrors-demo-logs.json';
                a.click();
            }
        }
            };
            
            const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `qerrors-demo-logs-${Date.now()}.json`;
            a.click();
            
            showNotification('Logs exported successfully', 'success');
        }

        // Utility functions
        function updateResponse(elementId, content, type = 'info') {
            const responseArea = document.getElementById(elementId);
            responseArea.className = 'response-area';
            
            if (type === 'error') {
                responseArea.classList.add('error-response');
            } else if (type === 'success') {
                responseArea.classList.add('success-response');
            }
            
            if (type === 'loading') {
                responseArea.innerHTML = `<div style="text-align: center;"><div class="loading"></div><p>${content}</p></div>`;
            } else {
                responseArea.innerHTML = `<pre>${content}</pre>`;
            }
        }

        function clearResponse() {
            updateResponse('error-response', 'Response will appear here...');
        }

        async function updateMetrics() {
            try {
                const response = await fetch('/api/metrics');
                const serverMetrics = await response.json();
                document.getElementById('total-errors').textContent = metrics.totalErrors;
                document.getElementById('queue-length').textContent = serverMetrics.qerrors.queueLength;
                document.getElementById('cache-hits').textContent = metrics.cacheHits;
                document.getElementById('ai-requests').textContent = metrics.aiRequests;
            } catch (error) {
                // Fallback to local metrics
                document.getElementById('total-errors').textContent = metrics.totalErrors;
                document.getElementById('queue-length').textContent = metrics.queueLength;
                document.getElementById('cache-hits').textContent = metrics.cacheHits;
                document.getElementById('ai-requests').textContent = metrics.aiRequests;
            }
        }

        function updateStatus(severity = 'normal') {
            const statusElement = document.getElementById('server-status');
            if (severity === 'critical') {
                statusElement.textContent = 'Server: Critical';
                statusElement.style.background = '#dc3545';
                statusElement.style.color = 'white';
                statusElement.style.borderColor = '#dc3545';
            } else {
                statusElement.textContent = 'Server: Connected';
                statusElement.className = 'status-item active';
            }
        }

        function generateErrorId() {
            return 'ERR_' + Math.random().toString(36).substr(2, 9).toUpperCase();
        }

        function getSeverityForType(type) {
            const severityMap = {
                validation: 'low',
                authentication: 'medium',
                authorization: 'medium',
                network: 'high',
                system: 'high',
                database: 'critical'
            };
            return severityMap[type] || 'medium';
        }

        function generateAIAdvice(errorType) {
            const adviceMap = {
                validation: 'Check input validation rules and sanitize user data',
                authentication: 'Verify authentication tokens and check user session validity',
                authorization: 'Review user permissions and access control mechanisms',
                network: 'Check network connectivity and external service availability',
                system: 'Review system logs and check resource utilization',
                database: 'Verify database connection and check query performance'
            };
            return {
                suggestion: adviceMap[errorType] || 'Review error context and system logs',
                confidence: Math.floor(Math.random() * 20) + 80,
                relatedDocs: `https://docs.qerrors.com/errors/${errorType}`
            };
        }

        function generateScenarioAnalysis(scenario) {
            const scenarios = {
                'database-connection': {
                    diagnosis: 'Database connection pool exhausted',
                    causes: ['High concurrent connections', 'Connection leaks', 'Database overload'],
                    solutions: [
                        'Increase connection pool size',
                        'Implement connection timeout',
                        'Add connection health checks'
                    ]
                },
                'api-timeout': {
                    diagnosis: 'External API service unresponsive',
                    causes: ['Network latency', 'Service degradation', 'Rate limiting'],
                    solutions: [
                        'Implement exponential backoff',
                        'Add circuit breaker pattern',
                        'Set appropriate timeouts'
                    ]
                },
                'memory-leak': {
                    diagnosis: 'Memory usage increasing continuously',
                    causes: ['Unclosed connections', 'Large object retention', 'Event listener leaks'],
                    solutions: [
                        'Profile memory usage',
                        'Implement object cleanup',
                        'Add memory monitoring'
                    ]
                },
                'race-condition': {
                    diagnosis: 'Concurrent access causing data inconsistency',
                    causes: ['Missing locks', 'Shared state mutation', 'Async operation ordering'],
                    solutions: [
                        'Implement proper locking',
                        'Use atomic operations',
                        'Add transaction boundaries'
                    ]
                },
                'file-permission': {
                    diagnosis: 'Insufficient file system permissions',
                    causes: ['Incorrect user permissions', 'Missing directory', 'SELinux restrictions'],
                    solutions: [
                        'Check file permissions',
                        'Verify directory existence',
                        'Review security policies'
                    ]
                }
            };
            return scenarios[scenario] || scenarios['database-connection'];
        }

        function showNotification(message, type = 'info') {
            // Simple notification - in production would use a proper notification system
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        

        

        

        

        


            
            const required = requiredElement.value.split(',').map(v => v.trim()).filter(v => v);
            const optional = optionalElement.value.split(',').map(v => v.trim()).filter(v => v);
            
            simulateAsyncOperation(() => {
                const envValidation = {
                    timestamp: new Date().toISOString(),
                    environment: 'development',
                    hasEnvFile: true,
                    isHealthy: required.length > 2, // Simulate some missing vars
                    required: {
                        total: required.length,
                        configured: required.length - 1,
                        missing: required.slice(0, 1)
                    },
                    optional: {
                        total: optional.length,
                        configured: optional.length - 2,
                        missing: optional.slice(0, 2)
                    },
                    summary: {
                        totalVars: required.length + optional.length,
                        configuredVars: (required.length - 1) + (optional.length - 2)
                    },
                    recommendations: [
                        'Add missing required variables to .env file',
                        'Consider setting optional variables for full functionality'
                    ]
                };
                
                updateResponse('environmentResponse', 'Environment Validation:\n' + JSON.stringify(envValidation, null, 2), envValidation.isHealthy ? 'success' : 'error');
            });
        }

        async function testEnvironmentHealth() {
            try {
                const response = await fetch('/api/health');
                const healthCheck = await response.json();
                
                updateResponse('environmentResponse', 'Environment Health:\n' + JSON.stringify(healthCheck, null, 2), 'success');
            } catch (error) {
                const healthCheck = {
                    status: 'unhealthy',
                    timestamp: new Date().toISOString(),
                    error: error.message,
                    overall: 'UNHEALTHY'
                };
                
                updateResponse('environmentResponse', 'Environment Health:\n' + JSON.stringify(healthCheck, null, 2), 'error');
            }
        }

        function testConfigRetrieval() {
            const keyElement = document.getElementById('configKey');
            const valueElement = document.getElementById('configValue');
            
            if (!keyElement || !valueElement) {
                console.error('Config form elements not found');
                return;
            }
            
            const key = keyElement.value || 'UNKNOWN_KEY';
            const value = valueElement.value || 'unknown';
            
            simulateAsyncOperation(() => {
                const configResult = {
                    key: key,
                    value: value,
                    source: 'environment',
                    type: typeof value,
                    isDefault: false,
                    metadata: {
                        retrievedAt: new Date().toISOString(),
                        fromCache: false,
                        validationStatus: 'valid'
                    }
                };
                
                updateResponse('configResponse', 'Config Retrieval:\n' + JSON.stringify(configResult, null, 2), 'success');
            });
        }

        function testConfigValidation() {
            simulateAsyncOperation(() => {
                const validation = {
                    configKey: 'QERRORS_AI_PROVIDER',
                    configValue: 'openai',
                    isValid: true,
                    allowedValues: ['openai', 'google', 'anthropic', 'none'],
                    validationRules: [
                        { rule: 'required', passed: true },
                        { rule: 'enum', passed: true },
                        { rule: 'type', passed: true, expected: 'string' }
                    ],
                    errors: [],
                    warnings: []
                };
                
                updateResponse('configResponse', 'Config Validation:\n' + JSON.stringify(validation, null, 2), 'success');
            });
        }

        function testLocalVariables() {
            simulateAsyncOperation(() => {
                const localVars = {
                    ERROR_TYPES: ['VALIDATION', 'AUTHENTICATION', 'AUTHORIZATION', 'NETWORK', 'SYSTEM'],
                    ERROR_SEVERITY: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
                    HTTP_STATUS: { OK: 200, BAD_REQUEST: 400, UNAUTHORIZED: 401, FORBIDDEN: 403, NOT_FOUND: 404, INTERNAL_ERROR: 500 },
                    DEFAULT_MESSAGES: {
                        success: 'Operation completed successfully',
                        error: 'An error occurred',
                        notFound: 'Resource not found',
                        unauthorized: 'Access denied'
                    },
                    MODEL_CONFIGS: {
                        openai: { model: 'gpt-4', timeout: 30000 },
                        google: { model: 'gemini-2.5-flash-lite', timeout: 25000 }
                    }
                };
                
                updateResponse('localVarsResponse', 'Local Variables:\n' + JSON.stringify(localVars, null, 2), 'success');
            });
        }

        function testVariableDefaults() {
            simulateAsyncOperation(() => {
                const defaults = {
                    QERRORS_AI_PROVIDER: 'openai',
                    QERRORS_AI_MODEL: 'gpt-4',
                    QERRORS_CACHE_LIMIT: 50,
                    QERRORS_CONCURRENCY_LIMIT: 5,
                    QERRORS_LOG_LEVEL: 'info',
                    QERRORS_TIMEOUT: 30000,
                    QERRORS_RETRY_ATTEMPTS: 3,
                    QERRORS_CIRCUIT_BREAKER_THRESHOLD: 5
                };
                
                updateResponse('localVarsResponse', 'Variable Defaults:\n' + JSON.stringify(defaults, null, 2), 'success');
            });
        }

        function testEnvironmentSwitch() {
            const targetElement = document.getElementById('targetEnvironment');
            
            if (!targetElement) {
                console.error('Target environment element not found');
                return;
            }
            
            const targetEnv = targetElement.value || 'development';
            
            simulateAsyncOperation(() => {
                const envSwitch = {
                    from: 'development',
                    to: targetEnv,
                    timestamp: new Date().toISOString(),
                    changes: [
                        { var: 'NODE_ENV', old: 'development', new: targetEnv },
                        { var: 'LOG_LEVEL', old: 'debug', new: targetEnv === 'production' ? 'error' : 'info' },
                        { var: 'QERRORS_AI_ENABLED', old: 'true', new: targetEnv === 'test' ? 'false' : 'true' }
                    ],
                    restartRequired: targetEnv === 'production',
                    status: 'success'
                };
                
                updateResponse('envSwitchResponse', 'Environment Switch:\n' + JSON.stringify(envSwitch, null, 2), 'success');
            });
        }

        function testEnvironmentDetection() {
            simulateAsyncOperation(() => {
                const detection = {
                    current: 'development',
                    detected: 'development',
                    indicators: {
                        NODE_ENV: 'development',
                        npm_lifecycle_event: 'start',
                        npm_config_loglevel: 'info',
                        platform: 'linux',
                        isTest: false,
                        isProduction: false
                    },
                    confidence: 0.95,
                    recommendations: [
                        'Environment correctly detected',
                        'Consider using .env files for configuration'
                    ]
                };
                
                updateResponse('envSwitchResponse', 'Environment Detection:\n' + JSON.stringify(detection, null, 2), 'success');
            });
        }


            
            const route = routeElement.value || '/api/test';
            const method = methodElement.value || 'GET';
            
            simulateAsyncOperation(() => {
                const middlewareTest = {
                    route: route,
                    method: method,
                    middleware: ['qerrors', 'auth', 'cors', 'rateLimit'],
                    request: {
                        headers: { 'content-type': 'application/json' },
                        body: { test: 'data' },
                        params: { id: '123' },
                        query: { debug: 'true' }
                    },
                    response: {
                        statusCode: 200,
                        headers: { 'x-powered-by': 'qerrors' },
                        body: { success: true, data: 'test response' }
                    },
                    processingTime: '45ms',
                    errorsHandled: 0
                };
                
                updateResponse('expressResponse', 'Express Middleware Test:\n' + JSON.stringify(middlewareTest, null, 2), 'success');
            });
        }

        function testErrorMiddleware() {
            simulateAsyncOperation(() => {
                const errorMiddleware = {
                    error: {
                        name: 'ValidationError',
                        message: 'Invalid input data',
                        statusCode: 400,
                        stack: 'Error: Invalid input\n    at validateInput (/app/middleware/validation.js:15:10)'
                    },
                    request: {
                        method: 'POST',
                        url: '/api/users',
                        headers: { 'content-type': 'application/json' }
                    },
                    response: {
                        statusCode: 400,
                        body: {
                            success: false,
                            error: {
                                message: 'Invalid input data',
                                type: 'ValidationError',
                                details: [
                                    { field: 'email', message: 'Invalid email format' },
                                    { field: 'age', message: 'Must be between 18 and 120' }
                                ]
                            }
                        }
                    },
                    logged: true,
                    notified: false
                };
                
                metrics.totalErrors++;
                updateResponse('expressResponse', 'Error Middleware Test:\n' + JSON.stringify(errorMiddleware, null, 2), 'error');
                updateMetrics();
            });
        }

        function testDatabaseIntegration() {
            const queryElement = document.getElementById('dbQuery');
            
            if (!queryElement) {
                console.error('Database query element not found');
                return;
            }
            
            const query = queryElement.value || 'SELECT * FROM users';
            
            simulateAsyncOperation(() => {
                const dbTest = {
                    query: query,
                    parameters: ['123'],
                    connection: {
                        host: 'localhost',
                        database: 'testdb',
                        pool: { active: 2, idle: 8, total: 10 }
                    },
                    execution: {
                        duration: '23ms',
                        rowsAffected: 1,
                        result: [{ id: 123, name: 'Test User', email: 'test@example.com' }]
                    },
                    errors: [],
                    transaction: false
                };
                
                updateResponse('databaseResponse', 'Database Integration Test:\n' + JSON.stringify(dbTest, null, 2), 'success');
            });
        }

        function testConnectionPool() {
            simulateAsyncOperation(() => {
                const poolTest = {
                    status: 'healthy',
                    pool: {
                        total: 10,
                        active: 3,
                        idle: 7,
                        waiting: 0
                    },
                    metrics: {
                        totalRequests: 1250,
                        totalConnections: 45,
                        avgConnectionTime: '12ms',
                        maxConnectionTime: '45ms'
                    },
                    health: {
                        isHealthy: true,
                        lastError: null,
                        uptime: '2h 34m'
                    }
                };
                
                updateResponse('databaseResponse', 'Connection Pool Test:\n' + JSON.stringify(poolTest, null, 2), 'success');
            });
        }

        function testExternalService() {
            const urlElement = document.getElementById('serviceUrl');
            const timeoutElement = document.getElementById('serviceTimeout');
            
            if (!urlElement || !timeoutElement) {
                console.error('External service form elements not found');
                return;
            }
            
            const url = urlElement.value || 'http://localhost:3001/api/data';
            const timeout = parseInt(timeoutElement.value) || 5000;
            
            // Make real API call
            const startTime = Date.now();
            fetch(url, {
                method: 'GET',
                headers: { 'user-agent': 'qerrors-demo/1.0' },
                signal: AbortSignal.timeout(timeout)
            }).then(response => {
                const duration = Date.now() - startTime;
                return response.json().then(data => ({
                    statusCode: response.status,
                    headers: { 'content-type': response.headers.get('content-type') },
                    body: data,
                    duration: duration + 'ms'
                }));
            }).then(responseData => {
                const serviceTest = {
                    url: url,
                    method: 'GET',
                    timeout: timeout,
                    request: {
                        headers: { 'user-agent': 'qerrors-demo/1.0' },
                        body: null
                    },
                    response: responseData,
                    circuitBreaker: {
                        state: 'closed',
                        failures: 0,
                        successes: 15
                    },
                    retries: 0
                };
                
                updateResponse('externalServiceResponse', 'External Service Test:\n' + JSON.stringify(serviceTest, null, 2), 'success');
            }).catch(error => {
                const serviceTest = {
                    url: url,
                    method: 'GET',
                    timeout: timeout,
                    error: error.message,
                    circuitBreaker: {
                        state: 'open',
                        failures: 1,
                        successes: 0
                    },
                    retries: 0
                };
                
                updateResponse('externalServiceResponse', 'External Service Test:\n' + JSON.stringify(serviceTest, null, 2), 'error');
            });
            
            const startTime = Date.now();
        }

        function testServiceFallback() {
            simulateAsyncOperation(() => {
                const fallbackTest = {
                    primaryService: {
                        url: 'https://api.primary.com',
                        status: 'failed',
                        error: 'Connection timeout',
                        attempts: 3
                    },
                    fallbackService: {
                        url: 'https://api.backup.com',
                        status: 'success',
                        response: { data: 'fallback response' },
                        duration: '1.2s'
                    },
                    totalDuration: '3.7s',
                    fallbackTriggered: true,
                    circuitBreakerState: 'open'
                };
                
                metrics.totalErrors += 3;
                updateResponse('externalServiceResponse', 'Service Fallback Test:\n' + JSON.stringify(fallbackTest, null, 2), 'error');
                updateMetrics();
            });
        }

        function testMessageQueue() {
            const queueElement = document.getElementById('queueName');
            
            if (!queueElement) {
                console.error('Queue name element not found');
                return;
            }
            
            const queueName = queueElement.value || 'error-processing';
            
            simulateAsyncOperation(() => {
                const queueTest = {
                    queue: queueName,
                    operation: 'publish',
                    message: {
                        id: generateUUID(),
                        type: 'error',
                        data: { error: 'Test error', context: 'demo' },
                        timestamp: new Date().toISOString()
                    },
                    result: {
                        success: true,
                        messageId: generateUUID(),
                        queueSize: 5,
                        consumers: 2
                    },
                    processing: {
                        enqueued: true,
                        priority: 'normal',
                        ttl: 3600
                    }
                };
                
                updateResponse('messageQueueResponse', 'Message Queue Test:\n' + JSON.stringify(queueTest, null, 2), 'success');
            });
        }

        function testQueueErrorHandling() {
            simulateAsyncOperation(() => {
                const queueErrorTest = {
                    queue: 'error-processing',
                    operation: 'consume',
                    error: {
                        type: 'ProcessingError',
                        message: 'Failed to process error message',
                        originalMessage: { id: '123', data: 'test' }
                    },
                    handling: {
                        retryAttempt: 2,
                        maxRetries: 3,
                        deadLetterQueue: 'error-processing-dlq',
                        backoffDelay: 5000
                    },
                    resolution: 'message_requeued'
                };
                
                metrics.totalErrors++;
                updateResponse('messageQueueResponse', 'Queue Error Handling:\n' + JSON.stringify(queueErrorTest, null, 2), 'error');
                updateMetrics();
            });
        }


        function testCustomError() {
            const nameElement = document.getElementById('errorName');
            const messageElement = document.getElementById('errorMessage');
            
            if (!nameElement || !messageElement) {
                console.error('Custom error elements not found');
                return;
            }
            
            const errorName = nameElement.value || 'CustomError';
            const errorMessage = messageElement.value || 'Custom error message';
            
            simulateAsyncOperation(() => {
                const customError = {
                    name: errorName,
                    message: errorMessage,
                    statusCode: 422,
                    severity: 'MEDIUM',
                    isOperational: true,
                    context: { businessLogic: true, domain: 'user-management' },
                    timestamp: new Date().toISOString(),
                    stack: `${errorName}: ${errorMessage}\n    at BusinessRuleValidator.validate (/app/validators/business.js:23:10)`,
                    metadata: {
                        errorCode: 'BUSINESS_VIOLATION',
                        category: 'domain-error',
                        recoverable: true
                    }
                };
                
                metrics.totalErrors++;
                updateResponse('customErrorResponse', 'Custom Error Type:\n' + JSON.stringify(customError, null, 2), 'error');
                updateMetrics();
            });
        }

        function testErrorInheritance() {
            simulateAsyncOperation(() => {
                const inheritanceTest = {
                    baseError: {
                        name: 'Error',
                        properties: ['message', 'name', 'stack']
                    },
                    serviceError: {
                        name: 'ServiceError',
                        extends: 'Error',
                        properties: ['type', 'context', 'statusCode', 'severity', 'timestamp'],
                        methods: ['toJSON', 'toString']
                    },
                    customError: {
                        name: 'BusinessLogicError',
                        extends: 'ServiceError',
                        properties: ['rule', 'domain', 'recoverable'],
                        methods: ['getSuggestions', 'isRecoverable']
                    },
                    prototypeChain: ['BusinessLogicError', 'ServiceError', 'Error', 'Object'],
                    instanceof: {
                        error: true,
                        serviceError: true,
                        businessLogicError: true
                    }
                };
                
                updateResponse('customErrorResponse', 'Error Inheritance Test:\n' + JSON.stringify(inheritanceTest, null, 2), 'success');
            });
        }

        function testContextEnhancement() {
            const contextElement = document.getElementById('contextData');
            
            if (!contextElement) {
                console.error('Context data element not found');
                return;
            }
            
            let contextData;
            try {
                contextData = JSON.parse(contextElement.value || '{}');
            } catch (e) {
                contextData = { userId: '123', action: 'update' };
            }
            
            simulateAsyncOperation(() => {
                const enhancedContext = {
                    base: contextData,
                    enhanced: {
                        ...contextData,
                        requestId: generateUUID(),
                        timestamp: new Date().toISOString(),
                        sessionId: 'sess_' + generateUUID().slice(0, 8),
                        userAgent: 'Demo Browser/1.0',
                        ip: '192.168.1.100',
                        environment: 'development',
                        version: '1.2.7',
                        correlationId: generateUUID()
                    },
                    security: {
                        authenticated: true,
                        authorized: true,
                        permissions: ['read', 'write'],
                        roles: ['user']
                    },
                    performance: {
                        startTime: new Date().toISOString(),
                        duration: null,
                        memoryUsage: '45.2MB'
                    }
                };
                
                updateResponse('contextResponse', 'Context Enhancement:\n' + JSON.stringify(enhancedContext, null, 2), 'success');
            });
        }

        function testContextChaining() {
            simulateAsyncOperation(() => {
                const chaining = {
                    step1: {
                        context: { operation: 'validate', step: 1 },
                        result: 'success',
                        timestamp: new Date().toISOString()
                    },
                    step2: {
                        context: { operation: 'process', step: 2, previousStep: 'validate' },
                        result: 'success',
                        timestamp: new Date().toISOString()
                    },
                    step3: {
                        context: { operation: 'persist', step: 3, previousStep: 'process' },
                        result: 'error',
                        error: 'Database connection failed',
                        timestamp: new Date().toISOString()
                    },
                    chain: {
                        totalSteps: 3,
                        successfulSteps: 2,
                        failedStep: 3,
                        overallResult: 'error',
                        contextFlow: ['validate', 'process', 'persist']
                    }
                };
                
                metrics.totalErrors++;
                updateResponse('contextResponse', 'Context Chaining:\n' + JSON.stringify(chaining, null, 2), 'error');
                updateMetrics();
            });
        }

        function testErrorAggregation() {
            const countElement = document.getElementById('errorCount');
            
            if (!countElement) {
                console.error('Error count element not found');
                return;
            }
            
            const count = parseInt(countElement.value) || 5;
            
            simulateAsyncOperation(() => {
                const errors = [];
                for (let i = 0; i < count; i++) {
                    errors.push({
                        id: `error_${i + 1}`,
                        type: ['ValidationError', 'NetworkError', 'SystemError'][i % 3],
                        message: `Error ${i + 1} in batch processing`,
                        timestamp: new Date(Date.now() - i * 1000).toISOString()
                    });
                }
                
                const aggregation = {
                    batchId: generateUUID(),
                    timestamp: new Date().toISOString(),
                    totalErrors: count,
                    errorTypes: {
                        ValidationError: Math.ceil(count / 3),
                        NetworkError: Math.ceil(count / 3),
                        SystemError: Math.floor(count / 3)
                    },
                    errors: errors,
                    summary: {
                        mostFrequent: 'ValidationError',
                        timeSpan: `${count} seconds`,
                        severity: 'MEDIUM'
                    }
                };
                
                metrics.totalErrors += count;
                updateResponse('aggregationResponse', 'Error Aggregation:\n' + JSON.stringify(aggregation, null, 2), 'error');
                updateMetrics();
            });
        }

        function testErrorBatching() {
            simulateAsyncOperation(() => {
                const batching = {
                    batchId: generateUUID(),
                    batchSize: 10,
                    processing: {
                        batchSize: 10,
                        maxBatchSize: 50,
                        currentBatch: 1,
                        totalBatches: 3
                    },
                    errors: [
                        { id: 1, type: 'ValidationError', batch: 1 },
                        { id: 2, type: 'NetworkError', batch: 1 },
                        { id: 3, type: 'SystemError', batch: 2 }
                    ],
                    performance: {
                        batchProcessingTime: '234ms',
                        avgErrorProcessingTime: '23ms',
                        throughput: '43 errors/sec'
                    }
                };
                
                updateResponse('aggregationResponse', 'Error Batching:\n' + JSON.stringify(batching, null, 2), 'success');
            });
        }

        function testAdvancedCaching() {
            const strategyElement = document.getElementById('cacheStrategy');
            
            if (!strategyElement) {
                console.error('Cache strategy element not found');
                return;
            }
            
            const strategy = strategyElement.value || 'lru';
            
            simulateAsyncOperation(() => {
                const advancedCache = {
                    strategy: strategy,
                    config: {
                        maxSize: 100,
                        ttl: 3600,
                        cleanupInterval: 300
                    },
                    performance: {
                        hitRate: '78.5%',
                        missRate: '21.5%',
                        avgLookupTime: '2.3ms',
                        memoryUsage: '15.6MB'
                    },
                    distribution: {
                        hotKeys: 15,
                        coldKeys: 85,
                        evictionRate: '5.2%',
                        fragmentation: '2.1%'
                    },
                    metrics: {
                        totalRequests: 10000,
                        cacheHits: 7850,
                        cacheMisses: 2150,
                        evictions: 52
                    }
                };
                
                updateResponse('advancedCacheResponse', 'Advanced Caching:\n' + JSON.stringify(advancedCache, null, 2), 'success');
            });
        }

        function testCacheDistribution() {
            simulateAsyncOperation(() => {
                const distribution = {
                    nodes: [
                        { id: 'node1', host: 'localhost', port: 11211, keys: 1250, memory: '45.2MB' },
                        { id: 'node2', host: 'localhost', port: 11212, keys: 1180, memory: '42.8MB' },
                        { id: 'node3', host: 'localhost', port: 11213, keys: 1320, memory: '48.1MB' }
                    ],
                    consistency: {
                        algorithm: 'consistent_hashing',
                        replicationFactor: 2,
                        syncStatus: 'healthy'
                    },
                    loadBalancing: {
                        strategy: 'round_robin',
                        distribution: 'even',
                        hotNodeDetection: true
                    },
                    health: {
                        overall: 'healthy',
                        failedNodes: 0,
                        recoveryTime: '0ms'
                    }
                };
                
                updateResponse('advancedCacheResponse', 'Cache Distribution:\n' + JSON.stringify(distribution, null, 2), 'success');
            });
        }

        // Security tests
        function testXSSProtection() {
            const payloadElement = document.getElementById('xssPayload');
            
            if (!payloadElement) {
                console.error('XSS payload element not found');
                return;
            }
            
            const payload = payloadElement.value || '<script>alert("test")</script>';
            
            simulateAsyncOperation(() => {
                const xssTest = {
                    originalPayload: payload,
                    escapedPayload: escapeHtml(payload),
                    safe: true,
                    response: {
                        error: {
                            message: escapeHtml(payload),
                            sanitized: true
                        }
                    }
                };
                
                updateResponse('xssResponse', 'XSS Protection Test:\n' + JSON.stringify(xssTest, null, 2), 'success');
            });
        }

        function testInputSanitization() {
            const maliciousInputElement = document.getElementById('maliciousInput');
            
            if (!maliciousInputElement) {
                console.error('Malicious input element not found');
                return;
            }
            
            const maliciousInput = maliciousInputElement.value || 'Test input';
            
            simulateAsyncOperation(() => {
                const sanitized = maliciousInput
                    .replace(/[\x00-\x1F\x7F]/g, '') // Remove control characters
                    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '[SCRIPT_REMOVED]')
                    .replace(/\n/g, '\\n')
                    .replace(/\t/g, '\\t');
                
                const sanitizationTest = {
                    original: maliciousInput,
                    sanitized: sanitized,
                    removed: {
                        controlChars: true,
                        scripts: true,
                        newlines: true,
                        tabs: true
                    },
                    safe: true
                };
                
                updateResponse('sanitizationResponse', 'Input Sanitization Test:\n' + JSON.stringify(sanitizationTest, null, 2), 'success');
            });
        }

        function testAPIKeySecurity() {
            simulateAsyncOperation(() => {
                const securityTest = {
                    apiKeyPresent: !!document.getElementById('apiKey').value,
                    apiKeyLogged: false,
                    apiKeyExposed: false,
                    headersSafe: true,
                    logsSafe: true,
                    status: 'SECURE'
                };
                
                updateResponse('securityResponse', 'API Key Security Test:\n' + JSON.stringify(securityTest, null, 2), 'success');
            });
        }

        function testSensitiveDataProtection() {
            simulateAsyncOperation(() => {
                const sensitiveDataTest = {
                    password: '[REDACTED]',
                    apiKey: '[REDACTED]',
                    token: '[REDACTED]',
                    secret: '[REDACTED]',
                    creditCard: '[REDACTED]',
                    ssN: '[REDACTED]',
                    status: 'SENSITIVE_DATA_PROTECTED'
                };
                
                updateResponse('securityResponse', 'Sensitive Data Protection:\n' + JSON.stringify(sensitiveDataTest, null, 2), 'success');
            });
        }

        function testContentNegotiation() {
            simulateAsyncOperation(() => {
                const contentTest = {
                    accepts: ['application/json', 'text/html', 'text/plain'],
                    provided: 'application/json',
                    negotiated: 'application/json',
                    safe: true
                };
                
                updateResponse('contentResponse', 'Content Negotiation Test:\n' + JSON.stringify(contentTest, null, 2), 'success');
            });
        }

        function testResponseSecurity() {
            simulateAsyncOperation(() => {
                const responseSecurity = {
                    headers: {
                        'X-Content-Type-Options': 'nosniff',
                        'X-Frame-Options': 'DENY',
                        'X-XSS-Protection': '1; mode=block',
                        'Content-Security-Policy': "default-src 'self'"
                    },
                    xssProtection: true,
                    clickjackingProtection: true,
                    contentTypeSniffingProtection: true,
                    status: 'SECURE'
                };
                
                updateResponse('contentResponse', 'Response Security Test:\n' + JSON.stringify(responseSecurity, null, 2), 'success');
            });
        }


            element.textContent = content;
            element.className = `response-area ${type}`;
        }

        function updateMetrics() {
            const totalErrorsElement = document.getElementById('totalErrors');
            const queueLengthElement = document.getElementById('queueLength');
            const cacheHitsElement = document.getElementById('cacheHits');
            const aiAnalysesElement = document.getElementById('aiAnalyses');
            const statusIndicatorElement = document.getElementById('systemStatus');
            
            if (totalErrorsElement) totalErrorsElement.textContent = metrics.totalErrors;
            if (queueLengthElement) queueLengthElement.textContent = metrics.queueLength;
            if (cacheHitsElement) cacheHitsElement.textContent = metrics.cacheHits;
            if (aiAnalysesElement) aiAnalysesElement.textContent = metrics.aiAnalyses;
            if (statusIndicatorElement) statusIndicatorElement.className = `status-indicator ${metrics.systemStatus}`;
        }

        function updateAvgResponseTime() {
            const avgResponseTimeElement = document.getElementById('avgResponseTime');
            if (!avgResponseTimeElement) {
                console.error('Average response time element not found');
                return;
            }
            
            if (responseTimes.length === 0) {
                avgResponseTimeElement.textContent = '0ms';
                return;
            }
            
            const avg = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
            avgResponseTimeElement.textContent = Math.round(avg) + 'ms';
            
            // Keep only last 50 response times
            if (responseTimes.length > 50) {
                responseTimes = responseTimes.slice(-50);
            }
        }

        function simulateAsyncOperation(callback) {
            // Show loading state
            setTimeout(() => {
                callback();
            }, Math.random() * 500 + 200); // Random delay between 200-700ms
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function generateSHA256(input) {
            // Simple hash simulation (not real SHA256)
            let hash = 0;
            for (let i = 0; i < input.length; i++) {
                const char = input.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16);
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        // Initialize metrics on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateMetrics();
            updateAvgResponseTime();
            
            // Simulate real-time metrics updates
            const metricsInterval = setInterval(() => {
                // Randomly update some metrics to simulate activity
                if (Math.random() > 0.7) {
                    metrics.queueLength = Math.max(0, metrics.queueLength + Math.floor(Math.random() * 3) - 1);
                    updateMetrics();
                }
            }, 2000);
            
            // Clean up interval on page unload to prevent memory leaks
            window.addEventListener('beforeunload', function() {
                if (metricsInterval) {
                    clearInterval(metricsInterval);
                }
            });
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Handling API Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.5em;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            background: rgba(102, 126, 234, 0.1);
            padding: 10px 20px;
            border-radius: 25px;
            border: 2px solid #667eea;
            font-weight: 500;
        }

        .status-item.active {
            background: #667eea;
            color: white;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }

        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .response-area {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .response-area pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
        }

        .error-response {
            border-color: #f5c6cb;
            background: #fff5f5;
        }

        .success-response {
            border-color: #c3e6cb;
            background: #f5fff5;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(102, 126, 234, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #667eea;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .metric-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid;
        }

        .alert-info {
            background: #d1ecf1;
            border-color: #0c5460;
            color: #0c5460;
        }

        .alert-warning {
            background: #fff3cd;
            border-color: #856404;
            color: #856404;
        }

        .alert-error {
            background: #f8d7da;
            border-color: #721c24;
            color: #721c24;
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .feature-list {
            list-style: none;
            padding: 0;
        }

        .feature-list li {
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .feature-list li:last-child {
            border-bottom: none;
        }

        .check-icon {
            color: #28a745;
            font-weight: bold;
        }

        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(26px);
        }

        
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                <div class="logo">Q</div>
                QErrors Module - Functional Demo
            </h1>
            <p class="subtitle">Intelligent Error Handling Middleware with AI-Powered Analysis</p>
            <div class="status-bar">
                <div class="status-item active" id="server-status">Server: Connected</div>
                <div class="status-item" id="ai-status">AI: Ready</div>
                <div class="status-item" id="cache-status">Cache: Active</div>
                <div class="status-item" id="queue-status">Queue: Empty</div>
            </div>
        </header>

        <div class="main-content">
            <div class="card">
                <h2>üß™ Error Testing</h2>
                
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('basic-errors')">Basic Errors</button>
                    <button class="tab" onclick="switchTab('custom-errors')">Custom Errors</button>
                    <button class="tab" onclick="switchTab('ai-analysis')">AI Analysis</button>
                </div>

                <div id="basic-errors" class="tab-content active">
                    <div class="form-group">
                        <label for="error-type">Error Type</label>
                        <select id="error-type">
                            <option value="validation">Validation Error</option>
                            <option value="authentication">Authentication Error</option>
                            <option value="authorization">Authorization Error</option>
                            <option value="network">Network Error</option>
                            <option value="system">System Error</option>
                            <option value="database">Database Error</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="error-message">Error Message</label>
                        <input type="text" id="error-message" placeholder="Enter custom error message" value="Test error message">
                    </div>

                    <div class="form-group">
                        <label for="error-context">Context (JSON)</label>
                        <textarea id="error-context" placeholder='{"userId": "123", "action": "create"}'>{"userId": "123", "action": "create"}</textarea>
                    </div>

                    <div class="btn-group">
                        <button class="btn" onclick="triggerError()">
                            ‚ö° Trigger Error
                        </button>
                        <button class="btn btn-danger" onclick="triggerCriticalError()">
                            üö® Critical Error
                        </button>
                        <button class="btn btn-secondary" onclick="clearResponse()">
                            üóëÔ∏è Clear
                        </button>
                    </div>
                </div>

                <div id="custom-errors" class="tab-content">
                    <div class="form-group">
                        <label for="custom-error-name">Error Name</label>
                        <input type="text" id="custom-error-name" placeholder="CustomErrorName" value="CustomBusinessError">
                    </div>

                    <div class="form-group">
                        <label for="custom-error-code">Error Code</label>
                        <input type="text" id="custom-error-code" placeholder="BUSINESS_RULE_VIOLATION" value="BUSINESS_RULE_VIOLATION">
                    </div>

                    <div class="form-group">
                        <label for="custom-error-severity">Severity</label>
                        <select id="custom-error-severity">
                            <option value="low">Low</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High</option>
                            <option value="critical">Critical</option>
                        </select>
                    </div>

                    <div class="btn-group">
                        <button class="btn" onclick="triggerCustomError()">
                            üéØ Trigger Custom Error
                        </button>
                        <button class="btn btn-success" onclick="testErrorRecovery()">
                            üîÑ Test Recovery
                        </button>
                    </div>
                </div>

                <div id="ai-analysis" class="tab-content">
                    <div class="form-group">
                        <label for="ai-scenario">AI Analysis Scenario</label>
                        <select id="ai-scenario">
                            <option value="database-connection">Database Connection Failed</option>
                            <option value="api-timeout">External API Timeout</option>
                            <option value="memory-leak">Memory Leak Detected</option>
                            <option value="race-condition">Race Condition</option>
                            <option value="file-permission">File Permission Error</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="ai-provider">AI Provider</label>
                        <select id="ai-provider">
                            <option value="openai">OpenAI GPT</option>
                            <option value="google">Google Gemini</option>
                            <option value="anthropic">Anthropic Claude</option>
                        </select>
                    </div>

                    <div class="btn-group">
                        <button class="btn" onclick="triggerAIAnalysis()">
                            ü§ñ Analyze with AI
                        </button>
                        <button class="btn btn-secondary" onclick="testAIHealth()">
                            üíâ AI Health Check
                        </button>
                    </div>
                </div>

                <div class="response-area" id="error-response">
                    <pre>Response will appear here...</pre>
                </div>
            </div>

            <div class="card">
                <h2>üìä System Metrics</h2>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="total-errors">0</div>
                        <div class="metric-label">Total Errors</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="queue-length">0</div>
                        <div class="metric-label">Queue Length</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="cache-hits">0</div>
                        <div class="metric-label">Cache Hits</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="ai-requests">0</div>
                        <div class="metric-label">AI Requests</div>
                    </div>
                </div>

                <h3>Configuration</h3>
                <div class="config-section">
                    <div class="config-grid">
                        <div class="config-item">
                            <span>AI Analysis</span>
                            <div class="toggle-switch active" id="ai-toggle" onclick="toggleConfig('ai')"></div>
                        </div>
                        <div class="config-item">
                            <span>Caching</span>
                            <div class="toggle-switch active" id="cache-toggle" onclick="toggleConfig('cache')"></div>
                        </div>
                        <div class="config-item">
                            <span>Queue Metrics</span>
                            <div class="toggle-switch active" id="metrics-toggle" onclick="toggleConfig('metrics')"></div>
                        </div>
                        <div class="config-item">
                            <span>Verbose Logging</span>
                            <div class="toggle-switch" id="verbose-toggle" onclick="toggleConfig('verbose')"></div>
                        </div>
                    </div>
                </div>

                <h3>Environment</h3>
                <div class="config-section">
                    <div class="config-grid">
                        <div class="config-item">
                            <span>Node Environment</span>
                            <span id="node-env">development</span>
                        </div>
                        <div class="config-item">
                            <span>Log Level</span>
                            <span id="log-level">info</span>
                        </div>
                        <div class="config-item">
                            <span>Cache TTL</span>
                            <span id="cache-ttl">24h</span>
                        </div>
                        <div class="config-item">
                            <span>Queue Limit</span>
                            <span id="queue-limit">100</span>
                        </div>
                    </div>
                </div>

                <h3>Actions</h3>
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="clearCache()">
                        üóëÔ∏è Clear Cache
                    </button>
                    <button class="btn btn-secondary" onclick="resetMetrics()">
                        üìä Reset Metrics
                    </button>
                    <button class="btn btn-success" onclick="exportLogs()">
                        üì• Export Logs
                    </button>
                </div>
            </div>
        </div>

        

        

        

        

        

        

        

        

        <div class="card">
            <h2>üöÄ Features & Capabilities</h2>
            <ul class="feature-list">
                <li><span class="check-icon">‚úì</span> AI-powered error analysis with multiple provider support</li>
                <li><span class="check-icon">‚úì</span> Intelligent caching system for cost optimization</li>
                <li><span class="check-icon">‚úì</span> Queue-based async processing with rate limiting</li>
                <li><span class="check-icon">‚úì</span> Comprehensive error typing and severity levels</li>
                <li><span class="check-icon">‚úì</span> Express middleware integration</li>
                <li><span class="check-icon">‚úì</span> Winston-based logging with daily rotation</li>
                <li><span class="check-icon">‚úì</span> Circuit breaker pattern for resilience</li>
                <li><span class="check-icon">‚úì</span> Environment variable validation</li>
                <li><span class="check-icon">‚úì</span> Performance monitoring and metrics</li>
                <li><span class="check-icon">‚úì</span> Content sanitization for security</li>
                <li><span class="check-icon">‚úì</span> Graceful degradation and error-safe design</li>
                <li><span class="check-icon">‚úì</span> TypeScript support with type definitions</li>
            </ul>
        </div>

        <div class="card">
            <h2>üìù API Endpoints Tested</h2>
            <div class="alert alert-info">
                <strong>Note:</strong> This demo tests the qerrors module functionality through simulated API calls. 
                In a real application, these would be actual Express middleware integrations.
            </div>
            <ul class="feature-list">
                <li><code>POST /api/errors/trigger</code> - Triggers various error types</li>
                <li><code>POST /api/errors/custom</code> - Creates custom business errors</li>
                <li><code>POST /api/errors/analyze</code> - AI-powered error analysis</li>
                <li><code>GET /api/metrics</code> - System performance metrics</li>
                <li><code>POST /api/config</code> - Dynamic configuration updates</li>
                <li><code>GET /api/health</code> - AI model health checks</li>
                <li><code>DELETE /api/cache</code> - Cache management operations</li>
                <li><code>GET /api/logs/export</code> - Log export functionality</li>
            </ul>
        </div>

        <div class="card">
            <h2>üß™ Advanced Testing Scenarios</h2>
            <div class="tabs">
                <button class="tab active" onclick="switchAdvancedTab('circuit-breaker')">Circuit Breaker</button>
                <button class="tab" onclick="switchAdvancedTab('queue-stress')">Queue Stress</button>
                <button class="tab" onclick="switchAdvancedTab('cache-performance')">Cache Performance</button>
                <button class="tab" onclick="switchAdvancedTab('ai-fallback')">AI Fallback</button>
            </div>

            <div id="circuit-breaker" class="tab-content active">
                <div class="form-group">
                    <label for="circuitThreshold">Failure Threshold:</label>
                    <input type="number" id="circuitThreshold" value="5" min="1" max="10">
                </div>
                <div class="form-group">
                    <label for="circuitTimeout">Timeout (ms):</label>
                    <input type="number" id="circuitTimeout" value="30000" min="1000" max="120000">
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="testCircuitBreaker()">Test Circuit Breaker</button>
                    <button class="btn btn-danger" onclick="forceCircuitOpen()">Force Open</button>
                    <button class="btn btn-success" onclick="resetCircuit()">Reset Circuit</button>
                </div>
            </div>

            <div id="queue-stress" class="tab-content">
                <div class="form-group">
                    <label for="stressConcurrency">Concurrent Requests:</label>
                    <input type="number" id="stressConcurrency" value="50" min="10" max="200">
                </div>
                <div class="form-group">
                    <label for="stressDuration">Duration (seconds):</label>
                    <input type="number" id="stressDuration" value="10" min="5" max="60">
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="startStressTest()">Start Stress Test</button>
                    <button class="btn btn-secondary" onclick="stopStressTest()">Stop Test</button>
                </div>
            </div>

            <div id="cache-performance" class="tab-content">
                <div class="form-group">
                    <label for="cacheSize">Cache Size:</label>
                    <input type="number" id="cacheSize" value="1000" min="100" max="10000">
                </div>
                <div class="form-group">
                    <label for="cacheTTL">TTL (seconds):</label>
                    <input type="number" id="cacheTTL" value="3600" min="60" max="86400">
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="benchmarkCache()">Benchmark Cache</button>
                    <button class="btn btn-secondary" onclick="testCacheEviction()">Test Eviction</button>
                </div>
            </div>

            <div id="ai-fallback" class="tab-content">
                <div class="form-group">
                    <label for="primaryAI">Primary AI Provider:</label>
                    <select id="primaryAI">
                        <option value="openai">OpenAI</option>
                        <option value="google">Google</option>
                        <option value="anthropic">Anthropic</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="fallbackAI">Fallback AI Provider:</label>
                    <select id="fallbackAI">
                        <option value="google">Google</option>
                        <option value="openai">OpenAI</option>
                        <option value="anthropic">Anthropic</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="testAIFallback()">Test AI Fallback</button>
                    <button class="btn btn-danger" onclick="simulateAIOutage()">Simulate Outage</button>
                </div>
            </div>

            <div class="response-area" id="advanced-response">
                <pre>Advanced test results will appear here...</pre>
            </div>
        </div>
    </div>
    </div>

    

    <script>
        // Global state
        let metrics = {
            totalErrors: 0,
            queueLength: 0,
            cacheHits: 0,
            aiRequests: 0
        };

        let config = {
            ai: true,
            cache: true,
            metrics: true,
            verbose: false
        };

        // Real API helper - replaces all mock simulateAsyncOperation calls
        async function callApi(endpoint, options = {}) {
            const method = options.method || 'GET';
            const body = options.body ? JSON.stringify(options.body) : undefined;
            const headers = { 'Content-Type': 'application/json', ...options.headers };
            
            try {
                const response = await fetch(endpoint, { method, headers, body });
                const data = await response.json();
                return { success: response.ok, data, status: response.status };
            } catch (err) {
                return { success: false, error: err.message, status: 0 };
            }
        }



        // Tab switching
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }

        // Advanced tab switching
        function switchAdvancedTab(tabId, event) {
            const advancedTabs = document.querySelectorAll('#circuit-breaker, #queue-stress, #cache-performance, #ai-fallback');
            const advancedTabButtons = document.querySelectorAll('.card:nth-child(3) .tab');
            
            advancedTabButtons.forEach(tab => tab.classList.remove('active'));
            advancedTabs.forEach(content => content.classList.remove('active'));
            
            // Fix: Use event parameter instead of undefined global event
            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(tabId).classList.add('active');
        }

        // Advanced testing functions - using real qerrors library via API
        async function testCircuitBreaker() {
            updateResponse('advanced-response', 'Testing circuit breaker with real qerrors library...', 'loading');
            
            const result = await callApi('/api/circuit/execute', { method: 'POST', body: { shouldFail: false } });
            if (result.success) {
                updateResponse('advanced-response', 'Circuit Breaker Test (REAL):\n' + JSON.stringify(result.data, null, 2), 'success');
            } else {
                updateResponse('advanced-response', 'Circuit Breaker Error:\n' + JSON.stringify(result, null, 2), 'error');
            }
        }

        async function forceCircuitOpen() {
            updateResponse('advanced-response', 'Triggering circuit failure with real qerrors library...', 'loading');
            
            const result = await callApi('/api/circuit/execute', { method: 'POST', body: { shouldFail: true } });
            const statusResult = await callApi('/api/circuit/status');
            const combined = { executeResult: result.data, circuitStatus: statusResult.data };
            updateResponse('advanced-response', 'Circuit Failure Triggered (REAL):\n' + JSON.stringify(combined, null, 2), 'warning');
        }

        async function resetCircuit() {
            updateResponse('advanced-response', 'Getting circuit breaker status with real qerrors library...', 'loading');
            
            const result = await callApi('/api/circuit/status');
            if (result.success) {
                updateResponse('advanced-response', 'Circuit Status (REAL):\n' + JSON.stringify(result.data, null, 2), 'success');
            } else {
                updateResponse('advanced-response', 'Circuit Status Error:\n' + JSON.stringify(result, null, 2), 'error');
            }
        }

        async function startStressTest() {
            const concurrencyElement = document.getElementById('stressConcurrency');
            const durationElement = document.getElementById('stressDuration');
            
            const concurrency = concurrencyElement ? parseInt(concurrencyElement.value) || 10 : 10;
            const iterations = durationElement ? parseInt(durationElement.value) || 5 : 5;
            
            updateResponse('advanced-response', `Running queue stress test with ${concurrency} concurrency, ${iterations} iterations...`, 'loading');
            
            const result = await callApi('/api/queue/execute', { method: 'POST', body: { iterations, priority: 'high' } });
            const stats = await callApi('/api/queue/status');
            const combined = { queueExecution: result.data, queueStats: stats.data };
            updateResponse('advanced-response', 'Queue Stress Test (REAL):\n' + JSON.stringify(combined, null, 2), result.success ? 'success' : 'error');
        }

        function stopStressTest() {
            updateResponse('advanced-response', 'Queue stress test stopped', 'warning');
        }

        async function benchmarkCache() {
            updateResponse('advanced-response', 'Getting real cache stats from qerrors library...', 'loading');
            
            const stats = await callApi('/api/queue/status');
            const cacheInfo = await callApi('/api/cache/clear', { method: 'POST' });
            const combined = { queueStats: stats.data, cacheCleared: cacheInfo.data };
            updateResponse('advanced-response', 'Cache Benchmark (REAL):\n' + JSON.stringify(combined, null, 2), stats.success ? 'success' : 'error');
        }

        async function testCacheEviction() {
            updateResponse('advanced-response', 'Testing cache with real qerrors library...', 'loading');
            
            const result = await callApi('/api/cache/clear', { method: 'POST' });
            updateResponse('advanced-response', 'Cache Eviction Test (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'warning');
        }

        async function testAIFallback() {
            updateResponse('advanced-response', 'Testing real AI analysis with Gemini API...', 'loading');
            
            const result = await callApi('/api/errors/analyze', { method: 'POST', body: { 
                error: { message: 'Database connection timeout', type: 'NetworkError' },
                context: { service: 'user-api', environment: 'production' }
            }});
            
            if (result.success) {
                updateResponse('advanced-response', 'AI Analysis (REAL Gemini API):\n' + JSON.stringify(result.data, null, 2), 'success');
            } else {
                updateResponse('advanced-response', 'AI Analysis Error:\n' + JSON.stringify(result, null, 2), 'error');
            }
        }

        async function simulateAIOutage() {
            updateResponse('advanced-response', 'Testing AI health check with real qerrors library...', 'loading');
            
            const result = await callApi('/api/health');
            updateResponse('advanced-response', 'AI Health Check (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        // Error triggering functions
        async function triggerError() {
            const errorTypeElement = document.getElementById('error-type');
            const messageElement = document.getElementById('error-message');
            
            if (!errorTypeElement || !messageElement) {
                console.error('Error test elements not found');
                return;
            }
            
            const errorType = errorTypeElement.value || 'ValidationError';
            const message = messageElement.value || 'Test error message';
            const contextStr = document.getElementById('error-context').value;
            
            let context;
            try {
                context = JSON.parse(contextStr);
            } catch (e) {
                context = { parseError: e.message };
            }

            updateResponse('error-response', 'Processing error...', 'loading');
            
            try {
                const response = await fetch('/api/errors/trigger', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        type: errorType.toLowerCase(), 
                        message, 
                        context 
                    })
                });
                
                const data = await response.json();
                metrics.totalErrors++;
                updateResponse('error-response', JSON.stringify(data, null, 2), 'success');
                updateMetrics();
            } catch (error) {
                // Fallback to mock response if backend is unavailable
                console.warn('Backend unavailable, using fallback:', error.message);
                
                const errorData = {
                    type: errorType,
                    message: message,
                    context: context,
                    timestamp: new Date().toISOString(),
                    severity: getSeverityForType(errorType)
                };
                
                metrics.totalErrors++;
                metrics.queueLength = Math.max(0, metrics.queueLength - 1);
                
                const fallbackResponse = {
                    success: true,
                    errorId: generateErrorId(),
                    error: errorData,
                    aiAdvice: config.ai ? generateAIAdvice(errorType) : null,
                    cached: config.cache && Math.random() > 0.7,
                    fallback: true
                };
                
                if (fallbackResponse.cached) metrics.cacheHits++;
                if (config.ai) metrics.aiRequests++;
                
                updateResponse('error-response', JSON.stringify(fallbackResponse, null, 2), 'success');
                updateMetrics();
            }
        }

        async function triggerCriticalError() {
            const criticalError = {
                type: 'system',
                message: 'Critical system failure detected',
                context: {
                    severity: 'critical',
                    systemState: 'degraded',
                    affectedServices: ['database', 'cache', 'queue']
                },
                timestamp: new Date().toISOString(),
                severity: 'critical'
            };

            updateResponse('error-response', 'Processing critical error...', 'error');
            
            setTimeout(() => {
                metrics.totalErrors += 5;
                metrics.queueLength += 3;
                
                const response = {
                    success: false,
                    errorId: generateErrorId(),
                    error: criticalError,
                    aiAdvice: config.ai ? {
                        level: 'critical',
                        immediate: 'Restart affected services immediately',
                        investigation: 'Check system logs for root cause',
                        prevention: 'Implement circuit breakers and health checks'
                    } : null,
                    escalation: 'CRITICAL',
                    notificationSent: true
                };
                
                updateResponse('error-response', JSON.stringify(response, null, 2), 'error');
                updateMetrics();
                updateStatus('critical');
            }, 1500);
        }

async function triggerCustomError() {
            const name = document.getElementById('custom-error-name').value;
            const code = document.getElementById('custom-error-code').value;
            const severity = document.getElementById('custom-error-severity').value;

            updateResponse('error-response', 'Processing custom error...', 'loading');
            
            try {
                const response = await fetch('/api/errors/custom', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name, 
                        code, 
                        message: `Custom business error: ${code}`,
                        severity,
                        context: {
                            businessRule: 'Custom validation failed',
                            department: 'engineering',
                            impact: 'medium'
                        }
                    })
                });
                
                const data = await response.json();
                metrics.totalErrors++;
                updateResponse('error-response', JSON.stringify(data, null, 2), 'success');
                updateMetrics();
            } catch (error) {
                // Fallback to mock response if backend is unavailable
                console.warn('Backend unavailable, using fallback:', error.message);
                
                const customError = {
                    name: name,
                    code: code,
                    message: `Custom business error: ${code}`,
                    type: 'business',
                    severity: severity,
                    context: {
                        businessRule: 'Custom validation failed',
                        department: 'engineering',
                        impact: 'medium'
                    },
                    timestamp: new Date().toISOString()
                };
                
                metrics.totalErrors++;
                
                const fallbackResponse = {
                    success: true,
                    errorId: generateErrorId(),
                    error: customError,
                    workflow: 'custom_error_handler',
                    businessLogic: 'Applied custom business rules',
                    recovery: 'Error handled by custom middleware',
                    fallback: true
                };
                
                updateResponse('error-response', JSON.stringify(fallbackResponse, null, 2), 'success');
                updateMetrics();
            }
        }

        async function testErrorRecovery() {
            updateResponse('error-response', 'Testing error recovery mechanisms...', 'loading');
            
            setTimeout(() => {
                const recoveryTest = {
                    scenario: 'error_recovery_test',
                    tests: [
                        { name: 'Circuit Breaker', status: 'PASS', response: 'Circuit opened successfully' },
                        { name: 'Retry Logic', status: 'PASS', response: '3 retries attempted, failed gracefully' },
                        { name: 'Fallback Response', status: 'PASS', response: 'Fallback data provided' },
                        { name: 'Queue Recovery', status: 'PASS', response: 'Queue processed after recovery' }
                    ],
                    overall: 'PASS',
                    recommendation: 'All recovery mechanisms working correctly'
                };
                
                updateResponse('error-response', JSON.stringify(recoveryTest, null, 2), 'success');
            }, 2000);
        }

        async function triggerAIAnalysis() {
            const scenario = document.getElementById('ai-scenario').value;
            const provider = document.getElementById('ai-provider').value;

            updateResponse('error-response', `Analyzing with ${provider} AI...`, 'loading');
            
            try {
                const response = await fetch('/api/errors/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        error: { 
                            message: `Test error for ${scenario} analysis`,
                            name: 'AnalysisTestError',
                            stack: new Error().stack
                        }, 
                        context: { scenario, provider } 
                    })
                });
                
                const data = await response.json();
                metrics.aiRequests++;
                updateResponse('error-response', JSON.stringify(data, null, 2), 'success');
                updateMetrics();
            } catch (error) {
                // Fallback to mock response if backend is unavailable
                console.warn('Backend unavailable, using fallback:', error.message);
                
                metrics.aiRequests++;
                
                const fallbackAnalysis = {
                    provider: provider,
                    scenario: scenario,
                    analysis: generateScenarioAnalysis(scenario),
                    confidence: Math.floor(Math.random() * 20) + 80,
                    processingTime: Math.floor(Math.random() * 1000) + 500,
                    cost: `$${(Math.random() * 0.05 + 0.01).toFixed(4)}`,
                    fallback: true
                };
                
                updateResponse('error-response', JSON.stringify(fallbackAnalysis, null, 2), 'success');
                updateMetrics();
            }
        }

        async function testAIHealth() {
            updateResponse('error-response', 'Checking AI model health...', 'loading');
            
            setTimeout(() => {
                const healthCheck = {
                    status: 'healthy',
                    models: {
                        openai: { status: 'healthy', latency: '234ms', lastCheck: new Date().toISOString() },
                        google: { status: 'healthy', latency: '189ms', lastCheck: new Date().toISOString() },
                        anthropic: { status: 'degraded', latency: '1200ms', lastCheck: new Date().toISOString() }
                    },
                    recommendations: [
                        'Anthropic model showing high latency, consider fallback',
                        'All other models performing within acceptable ranges'
                    ]
                };
                
                updateResponse('error-response', JSON.stringify(healthCheck, null, 2), 'success');
            }, 1500);
        }

        // Configuration functions
        function toggleConfig(configName) {
            config[configName] = !config[configName];
            const toggle = document.getElementById(`${configName}-toggle`);
            toggle.classList.toggle('active');
            
            // Show feedback
            const status = config[configName] ? 'enabled' : 'disabled';
            showNotification(`${configName.toUpperCase()} ${status}`, 'info');
        }

        function clearCache() {
            metrics.cacheHits = 0;
            showNotification('Cache cleared successfully', 'success');
            updateMetrics();
        }

        function resetMetrics() {
            metrics = {
                totalErrors: 0,
                queueLength: 0,
                cacheHits: 0,
                aiRequests: 0
            };
            showNotification('Metrics reset successfully', 'success');
            updateMetrics();
        }

        async function exportLogs() {
            try {
                const response = await fetch('/api/logs/export');
                const serverLogs = await response.json();
                
                const logs = {
                    timestamp: new Date().toISOString(),
                    serverLogs: serverLogs.logs,
                    metrics: metrics,
                    config: config,
                    demoSession: {
                        duration: '5 minutes',
                        errorsTested: metrics.totalErrors,
                        aiRequests: metrics.aiRequests
                    }
                };
                
                const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'qerrors-demo-logs.json';
                a.click();
            } catch (error) {
                // Fallback to local logs
                const logs = {
                    timestamp: new Date().toISOString(),
                    error: 'Failed to fetch server logs',
                    metrics: metrics,
                    config: config,
                    demoSession: {
                        duration: '5 minutes',
                        errorsTested: metrics.totalErrors,
                        aiRequests: metrics.aiRequests
                    }
                };
                
                const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'qerrors-demo-logs.json';
                a.click();
            }
        }
        
        // Utility functions
        function updateResponse(elementId, content, type = 'info') {
            const responseArea = document.getElementById(elementId);
            if (!responseArea) {
                console.error(`Element with ID '${elementId}' not found`);
                return;
            }
            
            responseArea.className = 'response-area';
            
            if (type === 'error') {
                responseArea.classList.add('error-response');
            } else if (type === 'success') {
                responseArea.classList.add('success-response');
            }
            
            if (type === 'loading') {
                responseArea.innerHTML = `<div style="text-align: center;"><div class="loading"></div><p></p></div>`;
                const pElement = responseArea.querySelector('p');
                if (pElement) pElement.textContent = content;
            } else {
                responseArea.innerHTML = `<pre></pre>`;
                const preElement = responseArea.querySelector('pre');
                if (preElement) preElement.textContent = content;
            }
        }

        function clearResponse() {
            updateResponse('error-response', 'Response will appear here...');
        }

        // Debounced metrics update to prevent excessive API calls
        let metricsDebounceTimer = null;
        async function updateMetrics() {
            // Clear existing timer
            if (metricsDebounceTimer) {
                clearTimeout(metricsDebounceTimer);
            }
            
            // Debounce the API call
            metricsDebounceTimer = setTimeout(async () => {
                try {
                    const response = await fetch('/api/metrics');
                    const serverMetrics = await response.json();
                    document.getElementById('total-errors').textContent = metrics.totalErrors;
                    document.getElementById('queue-length').textContent = serverMetrics.qerrors.queueLength;
                    document.getElementById('cache-hits').textContent = metrics.cacheHits;
                    document.getElementById('ai-requests').textContent = metrics.aiRequests;
                } catch (error) {
                    // Fallback to local metrics
                    document.getElementById('total-errors').textContent = metrics.totalErrors;
                    document.getElementById('queue-length').textContent = metrics.queueLength;
                    document.getElementById('cache-hits').textContent = metrics.cacheHits;
                    document.getElementById('ai-requests').textContent = metrics.aiRequests;
                }
            }, 500); // 500ms debounce
        }

        function updateStatus(severity = 'normal') {
            const statusElement = document.getElementById('server-status');
            if (severity === 'critical') {
                statusElement.textContent = 'Server: Critical';
                statusElement.style.background = '#dc3545';
                statusElement.style.color = 'white';
                statusElement.style.borderColor = '#dc3545';
            } else {
                statusElement.textContent = 'Server: Connected';
                statusElement.className = 'status-item active';
            }
        }

        function generateErrorId() {
            return 'ERR_' + Math.random().toString(36).substr(2, 9).toUpperCase();
        }

        function getSeverityForType(type) {
            const severityMap = {
                validation: 'low',
                authentication: 'medium',
                authorization: 'medium',
                network: 'high',
                system: 'high',
                database: 'critical'
            };
            return severityMap[type] || 'medium';
        }

        function generateAIAdvice(errorType) {
            const adviceMap = {
                validation: 'Check input validation rules and sanitize user data',
                authentication: 'Verify authentication tokens and check user session validity',
                authorization: 'Review user permissions and access control mechanisms',
                network: 'Check network connectivity and external service availability',
                system: 'Review system logs and check resource utilization',
                database: 'Verify database connection and check query performance'
            };
            return {
                suggestion: adviceMap[errorType] || 'Review error context and system logs',
                confidence: Math.floor(Math.random() * 20) + 80,
                relatedDocs: `https://docs.qerrors.com/errors/${errorType}`
            };
        }

        function generateScenarioAnalysis(scenario) {
            const scenarios = {
                'database-connection': {
                    diagnosis: 'Database connection pool exhausted',
                    causes: ['High concurrent connections', 'Connection leaks', 'Database overload'],
                    solutions: [
                        'Increase connection pool size',
                        'Implement connection timeout',
                        'Add connection health checks'
                    ]
                },
                'api-timeout': {
                    diagnosis: 'External API service unresponsive',
                    causes: ['Network latency', 'Service degradation', 'Rate limiting'],
                    solutions: [
                        'Implement exponential backoff',
                        'Add circuit breaker pattern',
                        'Set appropriate timeouts'
                    ]
                },
                'memory-leak': {
                    diagnosis: 'Memory usage increasing continuously',
                    causes: ['Unclosed connections', 'Large object retention', 'Event listener leaks'],
                    solutions: [
                        'Profile memory usage',
                        'Implement object cleanup',
                        'Add memory monitoring'
                    ]
                },
                'race-condition': {
                    diagnosis: 'Concurrent access causing data inconsistency',
                    causes: ['Missing locks', 'Shared state mutation', 'Async operation ordering'],
                    solutions: [
                        'Implement proper locking',
                        'Use atomic operations',
                        'Add transaction boundaries'
                    ]
                },
                'file-permission': {
                    diagnosis: 'Insufficient file system permissions',
                    causes: ['Incorrect user permissions', 'Missing directory', 'SELinux restrictions'],
                    solutions: [
                        'Check file permissions',
                        'Verify directory existence',
                        'Review security policies'
                    ]
                }
            };
            return scenarios[scenario] || scenarios['database-connection'];
        }

        function showNotification(message, type = 'info') {
            // Simple notification - in production would use a proper notification system
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        async function validateEnvironment() {
            const requiredElement = document.getElementById('requiredVars');
            const required = requiredElement ? requiredElement.value.split(',').map(v => v.trim()).filter(v => v) : ['NODE_ENV'];
            
            const result = await callApi('/api/config/validate-env', { method: 'POST', body: { requiredVars: required } });
            updateResponse('environmentResponse', 'Environment Validation (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testEnvironmentHealth() {
            try {
                const response = await fetch('/api/health');
                const healthCheck = await response.json();
                
                updateResponse('environmentResponse', 'Environment Health:\n' + JSON.stringify(healthCheck, null, 2), 'success');
            } catch (error) {
                const healthCheck = {
                    status: 'unhealthy',
                    timestamp: new Date().toISOString(),
                    error: error.message,
                    overall: 'UNHEALTHY'
                };
                
                updateResponse('environmentResponse', 'Environment Health:\n' + JSON.stringify(healthCheck, null, 2), 'error');
            }
        }

        async function testConfigRetrieval() {
            const result = await callApi('/api/config/env');
            updateResponse('configResponse', 'Config Retrieval (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testConfigValidation() {
            const result = await callApi('/api/library-functions');
            updateResponse('configResponse', 'Library Functions (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testLocalVariables() {
            const result = await callApi('/api/log-levels');
            updateResponse('localVarsResponse', 'Log Levels & Error Types (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testVariableDefaults() {
            const result = await callApi('/api/config/env');
            updateResponse('localVarsResponse', 'Config Defaults (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testEnvironmentSwitch() {
            const result = await callApi('/api/health');
            updateResponse('envSwitchResponse', 'Environment Status (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testEnvironmentDetection() {
            const result = await callApi('/api/config/env');
            updateResponse('envSwitchResponse', 'Environment Detection (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testExpressMiddleware() {
            const result = await callApi('/api/response-helpers/demo', { method: 'POST', body: { type: 'success' } });
            updateResponse('expressResponse', 'Response Helper Test (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testErrorMiddleware() {
            const result = await callApi('/api/response-helpers/demo', { method: 'POST', body: { type: 'error' } });
            metrics.totalErrors++;
            updateResponse('expressResponse', 'Error Response Test (REAL):\n' + JSON.stringify(result.data, null, 2), 'error');
            updateMetrics();
        }

        async function testDatabaseIntegration() {
            const result = await callApi('/api/entity-guards/test', { method: 'POST', body: { action: 'exists' } });
            updateResponse('databaseResponse', 'Entity Guard Test (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testConnectionPool() {
            const result = await callApi('/api/queue/status');
            updateResponse('databaseResponse', 'Queue Pool Stats (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        function testExternalService() {
            const urlElement = document.getElementById('serviceUrl');
            const timeoutElement = document.getElementById('serviceTimeout');
            
            if (!urlElement || !timeoutElement) {
                console.error('External service form elements not found');
                return;
            }
            
            const url = urlElement.value || 'http://localhost:3001/api/data';
            const timeout = parseInt(timeoutElement.value) || 5000;
            
            // Make real API call
            const startTime = Date.now();
            fetch(url, {
                method: 'GET',
                headers: { 'user-agent': 'qerrors-demo/1.0' },
                signal: AbortSignal.timeout(timeout)
            }).then(response => {
                const duration = Date.now() - startTime;
                return response.json().then(data => ({
                    statusCode: response.status,
                    headers: { 'content-type': response.headers.get('content-type') },
                    body: data,
                    duration: duration + 'ms'
                }));
            }).then(responseData => {
                const serviceTest = {
                    url: url,
                    method: 'GET',
                    timeout: timeout,
                    request: {
                        headers: { 'user-agent': 'qerrors-demo/1.0' },
                        body: null
                    },
                    response: responseData,
                    circuitBreaker: {
                        state: 'closed',
                        failures: 0,
                        successes: 15
                    },
                    retries: 0
                };
                
                updateResponse('externalServiceResponse', 'External Service Test:\n' + JSON.stringify(serviceTest, null, 2), 'success');
            }).catch(error => {
                const serviceTest = {
                    url: url,
                    method: 'GET',
                    timeout: timeout,
                    error: error.message,
                    circuitBreaker: {
                        state: 'open',
                        failures: 1,
                        successes: 0
                    },
                    retries: 0
                };
                
                updateResponse('externalServiceResponse', 'External Service Test:\n' + JSON.stringify(serviceTest, null, 2), 'error');
            });
        }

        async function testServiceFallback() {
            const result = await callApi('/api/circuit/status');
            metrics.totalErrors++;
            updateResponse('externalServiceResponse', 'Circuit Breaker Fallback (REAL):\n' + JSON.stringify(result.data, null, 2), 'warning');
            updateMetrics();
        }

        async function testMessageQueue() {
            const result = await callApi('/api/queue/execute', { method: 'POST', body: { iterations: 3, priority: 'normal' } });
            updateResponse('messageQueueResponse', 'Queue Execution (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testQueueErrorHandling() {
            const result = await callApi('/api/queue/status');
            metrics.totalErrors++;
            updateResponse('messageQueueResponse', 'Queue Stats (REAL):\n' + JSON.stringify(result.data, null, 2), 'warning');
            updateMetrics();
        }

        async function testCustomError() {
            const nameElement = document.getElementById('errorName');
            const messageElement = document.getElementById('errorMessage');
            const errorName = nameElement ? nameElement.value || 'CustomError' : 'CustomError';
            const errorMessage = messageElement ? messageElement.value || 'Custom error' : 'Custom error';
            
            const result = await callApi('/api/errors/custom', { method: 'POST', body: { name: errorName, code: 'CUSTOM_ERROR', severity: 'high' } });
            metrics.totalErrors++;
            updateResponse('customErrorResponse', 'Custom Error (REAL):\n' + JSON.stringify(result.data, null, 2), 'error');
            updateMetrics();
        }

        async function testErrorInheritance() {
            const result = await callApi('/api/errors/standard', { method: 'POST', body: { type: 'validation', message: 'Inheritance test' } });
            updateResponse('customErrorResponse', 'Standard Error (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testContextEnhancement() {
            const result = await callApi('/api/sanitize', { method: 'POST', body: { message: 'Test message with context', context: { userId: '123', action: 'update' } } });
            updateResponse('contextResponse', 'Context Sanitization (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testContextChaining() {
            const result = await callApi('/api/unique-id');
            metrics.totalErrors++;
            updateResponse('contextResponse', 'Unique ID Generation (REAL):\n' + JSON.stringify(result.data, null, 2), 'success');
            updateMetrics();
        }

        async function testErrorAggregation() {
            const countElement = document.getElementById('errorCount');
            const count = countElement ? parseInt(countElement.value) || 5 : 5;
            
            const result = await callApi('/api/logs/export');
            metrics.totalErrors += count;
            updateResponse('aggregationResponse', 'Log Buffer (REAL):\n' + JSON.stringify(result.data, null, 2), 'warning');
            updateMetrics();
        }

        async function testErrorBatching() {
            const result = await callApi('/api/metrics');
            updateResponse('aggregationResponse', 'Server Metrics (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testAdvancedCaching() {
            const result = await callApi('/api/queue/status');
            updateResponse('advancedCacheResponse', 'Queue & Cache Stats (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testCacheDistribution() {
            const result = await callApi('/api/library-functions');
            updateResponse('advancedCacheResponse', 'Library Distribution (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        // Security tests - using real qerrors sanitization API
        async function testXSSProtection() {
            const payloadElement = document.getElementById('xssPayload');
            const payload = payloadElement ? payloadElement.value || '<script>alert("xss")<\/script>' : '<script>alert("xss")<\/script>';
            
            const result = await callApi('/api/sanitize', { method: 'POST', body: { message: payload, context: { xssTest: true } } });
            updateResponse('xssResponse', 'XSS Sanitization (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testInputSanitization() {
            const maliciousInputElement = document.getElementById('maliciousInput');
            const maliciousInput = maliciousInputElement ? maliciousInputElement.value || 'Test with password=secret123' : 'Test with password=secret123';
            
            const result = await callApi('/api/sanitize', { method: 'POST', body: { message: maliciousInput, context: { apiKey: 'sk-test-12345', password: 'secret' } } });
            updateResponse('sanitizationResponse', 'Input Sanitization (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testAPIKeySecurity() {
            const result = await callApi('/api/sanitize', { method: 'POST', body: { message: 'API key test', context: { apiKey: 'sk-sensitive-key-12345', secret: 'mysecret' } } });
            updateResponse('securityResponse', 'API Key Sanitization (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testSensitiveDataProtection() {
            const result = await callApi('/api/sanitize', { method: 'POST', body: { 
                message: 'Sensitive data protection test',
                context: { password: 'secretpass', apiKey: 'sk-12345', token: 'jwt-token', creditCard: '4111111111111111' }
            }});
            updateResponse('securityResponse', 'Sensitive Data Protection (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testContentNegotiation() {
            const result = await callApi('/api/response-helpers/demo', { method: 'POST', body: { type: 'success' } });
            updateResponse('contentResponse', 'Content Negotiation (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        async function testResponseSecurity() {
            const result = await callApi('/api/health');
            updateResponse('contentResponse', 'Response Security (REAL):\n' + JSON.stringify(result.data, null, 2), result.success ? 'success' : 'error');
        }

        function updateMetrics() {
            const totalErrorsElement = document.getElementById('totalErrors');
            const queueLengthElement = document.getElementById('queueLength');
            const cacheHitsElement = document.getElementById('cacheHits');
            const aiAnalysesElement = document.getElementById('aiAnalyses');
            const statusIndicatorElement = document.getElementById('systemStatus');
            
            if (totalErrorsElement) totalErrorsElement.textContent = metrics.totalErrors;
            if (queueLengthElement) queueLengthElement.textContent = metrics.queueLength;
            if (cacheHitsElement) cacheHitsElement.textContent = metrics.cacheHits;
            if (aiAnalysesElement) aiAnalysesElement.textContent = metrics.aiAnalyses;
            if (statusIndicatorElement) {
                const allowedStatuses = ['healthy', 'warning', 'error', 'unknown'];
                const safeStatus = allowedStatuses.includes(metrics.systemStatus) ? metrics.systemStatus : 'unknown';
                statusIndicatorElement.className = `status-indicator ${safeStatus}`;
            }
        }

        function updateAvgResponseTime() {
            const avgResponseTimeElement = document.getElementById('avgResponseTime');
            if (!avgResponseTimeElement) {
                console.error('Average response time element not found');
                return;
            }
            
            if (responseTimes.length === 0) {
                avgResponseTimeElement.textContent = '0ms';
                return;
            }
            
            const avg = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
            avgResponseTimeElement.textContent = Math.round(avg) + 'ms';
            
            // Keep only last 50 response times
            if (responseTimes.length > 50) {
                responseTimes = responseTimes.slice(-50);
            }
        }

        function simulateAsyncOperation(callback) {
            // Show loading state
            setTimeout(() => {
                callback();
            }, Math.random() * 500 + 200); // Random delay between 200-700ms
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        async function generateSHA256(input) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(input);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (error) {
                console.error('SHA256 generation failed:', error);
                // Fallback to simple hash for browsers without Web Crypto API
                // Handles Unicode properly by iterating over code points
                let hash = 0;
                for (const char of input) {
                    const code = char.codePointAt(0);
                    hash = ((hash << 5) - hash) + code;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16);
            }
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        // Initialize metrics on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateMetrics();
            updateAvgResponseTime();
            
            // Simulate real-time metrics updates
            const metricsInterval = setInterval(() => {
                // Randomly update some metrics to simulate activity
                if (Math.random() > 0.7) {
                    metrics.queueLength = Math.max(0, metrics.queueLength + Math.floor(Math.random() * 3) - 1);
                    updateMetrics();
                }
            }, 2000);
            
            // Clean up interval on page unload to prevent memory leaks
            window.addEventListener('beforeunload', function() {
                if (metricsInterval) {
                    clearInterval(metricsInterval);
                }
            });
        });
    </script>
</body>
</html>
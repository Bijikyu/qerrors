import express from 'express';import cors from 'cors';import path from 'path';import{createRequire}from'module';import compression from'compression';import rateLimit from'express-rate-limit';const{MemoryMonitor,MemoryUtils}=require('./lib/memoryManagement');const require=createRequire(import.meta.url);const{qerrors}=require('./index.js');const jwt=require('jsonwebtoken');

const memoryMonitor=new MemoryMonitor({warningThreshold:50*1024*1024,criticalThreshold:100*1024*1024,checkInterval:10000});const apiLimiter=rateLimit({windowMs:15*60*1000,max:1000,message:{error:'Too many requests',retryAfter:15*60},standardHeaders:true,legacyHeaders:false,keyGenerator:req=>req.ip||req.connection.remoteAddress});const app=express();

app.use(cors({origin:process.env.ALLOWED_ORIGINS?.split(',')||'*',credentials:true}));app.use(compression({threshold:1024}));app.use(express.json({limit:'1mb',strict:false,type:'application/json'}));app.use(express.urlencoded({limit:'1mb',extended:true,parameterLimit:1000}));app.use('/api/',apiLimiter);app.use(express.static('.',{maxAge:'1h',etag:true,lastModified:true}));

app.use((req,res,next)=>{const memoryUsage=process.memoryUsage();req.memoryContext={heapUsed:memoryUsage.heapUsed,heapTotal:memoryUsage.heapTotal,external:memoryUsage.external,timestamp:Date.now()};const originalSend=res.send;res.send=function(data){res.memoryAfter=process.memoryUsage();return originalSend.call(this,data);};next();});

app.get('/health',(req,res)=>{const memoryStats=memoryMonitor.getMemoryStats();res.json({status:'healthy',timestamp:new Date().toISOString(),uptime:process.uptime(),memory:memoryStats,rateLimiting:{limit:1000,remaining:'N/A'}});});app.get('/metrics',(req,res)=>{const memoryStats=memoryMonitor.getMemoryStats();res.json({timestamp:new Date().toISOString(),memory:memoryStats,uptime:process.uptime(),performance:MemoryUtils.getPerformanceStats()});});

app.get('/api/data',async(req,res,next)=>{try{const data={message:'Sample data',timestamp:new Date().toISOString(),data:Array.from({length:10},(_,i)=>({id:i+1,name:`Item ${i+1}`,value:Math.random()*100}))};res.json({success:true,data,count:data.data.length});}catch(error){next(error);}});

app.get('/api/error',(req,res,next)=>{const errorType=req.query.type||'basic';switch(errorType){case'type':next(new TypeError('Invalid type'));break;case'reference':next(new ReferenceError('Property not found'));break;case'range':next(new RangeError('Value out of range'));break;case'syntax':next(new SyntaxError('Invalid syntax'));break;case'custom':next(new Error('Custom error: <script>alert("xss")</script>'));break;default:next(new Error('Basic error'));break;}});

app.post('/api/validate',(req,res,next)=>{try{const{email,name,age}=req.body;const errors=[];(!email||!email.includes('@'))&&errors.push('Valid email required');(!name||name.length<2)&&errors.push('Name must be 2+ chars');(!age||age<0||age>150)&&errors.push('Age must be 0-150');if(errors.length){const validationError=new Error('Validation failed');validationError.validationErrors=errors;next(validationError);return;}res.json({success:true,message:'Validation successful',data:{email,name,age}});}catch(error){next(error);}});

app.post('/api/errors/trigger',(req,res,next)=>{try{const{type,message,context}=req.body;let error;switch(type){case'async':setTimeout(()=>{error=new Error(message||'Async error');error.context=context;next(error);},100);return;case'promise':Promise.reject(new Error(message||'Promise rejected')).catch(err=>next(err));return;case'timeout':setTimeout(()=>{error=new Error(message||'Timeout');error.code='TIMEOUT';next(error);},5000);return;default:error=new Error(message||'Error triggered');error.context=context;next(error);break;}}catch(error){next(error);}});

app.post('/api/errors/custom',(req,res,next)=>{try{const{errorType,message,code,severity,stack,context}=req.body;const error=new Error(message||'Custom error');errorType&&(error.name=errorType);code&&(error.code=code);severity&&(error.severity=severity);stack&&(error.stack=stack);context&&(error.context=context);next(error);}catch(error){next(error);}});

app.post('/api/errors/analyze',async(req,res,next)=>{try{const{errorData,enableAnalysis}=req.body;const error=new Error(errorData.message||'Error to analyze');errorData.name&&(error.name=errorData.name);errorData.code&&(error.code=errorData.code);if(enableAnalysis){await qerrors(error,'api-server.routes.analyze',{endpoint:'/api/errors/analyze',errorData,analysisRequested:true},req,res,next);}else{res.json({success:false,error:error.message,name:error.name,code:error.code,analysis:'disabled'});}}catch(error){next(error);}});

app.use(async(error,req,res,next)=>{if(res.headersSent){console.error('Error after headers sent:',error.message);return;}const context={url:req.url,method:req.method,ip:req.ip||req.connection.remoteAddress,userAgent:req.get('User-Agent'),memoryBefore:req.memoryContext,memoryAfter:res.memoryAfter,timestamp:Date.now()};try{const result=await qerrors(error,'api-server.middleware',context);if(req.accepts('html')){res.status(500).set('Content-Type','text/html').send(`<!DOCTYPE html><html><head><title>Error</title></head><body><h1>Internal Server Error</h1><p>Error ID: ${result.errorId||'N/A'}</p><pre>${error.message||'Unknown error'}</pre></body></html>`);}else{res.status(500).json({error:'Internal Server Error',errorId:result.errorId,message:error.message,timestamp:new Date().toISOString()});}}catch(handlingError){console.error('qerrors failed:',handlingError.message);if(!res.headersSent){res.status(500).json({error:'Internal Server Error',message:'Unexpected error',timestamp:new Date().toISOString(),fallback:true});}}});

app.use((req,res)=>res.status(404).json({error:'Not Found',message:`Route ${req.method} ${req.url} not found`,timestamp:new Date().toISOString()}));const PORT=process.env.PORT||3000;app.listen(PORT,()=>{console.log(`Express API server running on port ${PORT}`);console.log(`Memory monitoring enabled`);console.log(`AI-powered error analysis enabled`);});
const safeRun = (name, fn, fallback, info) => { try { return fn(); } catch (err) { console.error(`${name} failed`, info); return fallback; } }; const stringifyContext = ctx => { try { if (typeof ctx === 'string') return ctx; if (typeof ctx === 'object' && ctx !== null) { const seen = new Set(); return JSON.stringify(ctx, (k, value) => { if (typeof value === 'object' && value !== null) { if (value === ctx) return '[Circular *1]'; if (seen.has(value)) return '[Circular]'; seen.add(value); } return value; }); } return String(ctx); } catch (err) { return 'unknown context'; } }; const verboseLog = msg => process.env.QERRORS_VERBOSE !== 'false' && console.log(msg); const { cloneDeep } = require('lodash'); const deepClone = obj => cloneDeep(obj); const createTimer = () => { const startTime = process.hrtime.bigint(); return { elapsed:() => Number(process.hrtime.bigint() - startTime) / 1000000, elapsedFormatted:() => { const ms = this.elapsed(); return ms < 1000 ? `${ms.toFixed(2)}ms` : ms < 60000 ? `${(ms / 1000).toFixed(2)}s` : `${(ms / 60000).toFixed(2)}m`; } }; }; const safeErrorMessage = (error, fallback) => { if (error && typeof error === 'object' && 'message' in error) { const msg = String(error.message || '').trim(); if (msg) return msg; } if (typeof error === 'string' && error.trim()) return error.trim(); return fallback; }; const logError = (error, context, metadata = {}) => { try { const qerrors = require('./qerrors'); if (typeof qerrors?.qerrors === 'function') { qerrors.qerrors(error, context, metadata); return; } if (typeof qerrors === 'function') { qerrors(error, context, metadata); return; } const logger = require('./logger'); if (typeof logger?.logError === 'function') logger.logError(safeErrorMessage(error, 'Unknown error'), { context, ...metadata }); } catch {} }; const logInfo = (message, metadata = {}) => { try { const logger = require('./logger'); typeof logger?.logInfo === 'function' && logger.logInfo(message, metadata); } catch {} }; const logWarn = (message, metadata = {}) => { try { const logger = require('./logger'); typeof logger?.logWarn === 'function' && logger.logWarn(message, metadata); } catch {} }; const safeQerrors = async (error, context, extra = {}) => { try { const qerrors = require('./qerrors'); const fn = typeof qerrors?.qerrors === 'function' ? qerrors.qerrors : null; if (fn) { await fn(error, context, extra); return; } } catch {} try { const message = error instanceof Error ? error.message : String(error); console.error(`[${context}]`, message, extra); } catch {} }; const attempt = async fn => { try { const value = await Promise.resolve().then(fn); return { ok: true, value }; } catch (error) { return { ok: false, error }; } }; const executeWithQerrors = async options => { const { opName, operation, context = {}, failureMessage, errorCode, errorType, logMessage, rethrow = true, fallbackValue } = options; try { return await operation(); } catch (error) { const errorContext = { opName, errorCode, errorType, ...context }; logError(error, logMessage || failureMessage, errorContext); if (rethrow) { if (error instanceof Error) error.message = `${failureMessage}: ${error.message}`; throw error; } return fallbackValue; } }; const formatErrorMessage = (error, context) => { const message = safeErrorMessage(error, 'Unknown error'); return context ? `[${context}] ${message}` : message; }; const createSafeAsyncWrapper = options => { const { modulePath = './qerrors', functionName = '', fallbackFn, silent = true, errorMessage } = options; return async function safeWrapper(...args) { try { const module = require(modulePath); if (module && functionName) { const fn = typeof module[functionName] === 'function' ? module[functionName] : null; if (fn) return await fn(...args); } } catch (error) { if (!silent) { const msg = errorMessage || `Failed to call ${functionName} from ${modulePath}`; console.warn(msg, error); } } if (fallbackFn) { try { return await fallbackFn(...args); } catch (fallbackError) { if (!silent) console.warn('Fallback function failed:', fallbackError); } } }; }; const createSafeLogger = (functionName, fallbackLevel = 'error') => { const fallbackFn = (message, details) => console[fallbackLevel](message, details); return createSafeAsyncWrapper({ modulePath: './qerrors', functionName, fallbackFn, errorMessage: `qerrors.${functionName} unavailable, using console.${fallbackLevel}` }); }; const createSafeOperation = (asyncFn, fallbackValue, onError) => async function safeOperation(...args) { try { return await asyncFn(...args); } catch (error) { onError && onError(error, ...args); return fallbackValue; } }; module.exports = { safeRun, stringifyContext, verboseLog, deepClone, createTimer, safeErrorMessage, logError, logInfo, logWarn, attempt, executeWithQerrors, formatErrorMessage, createSafeAsyncWrapper, createSafeLogger, createSafeOperation, safeQerrors };
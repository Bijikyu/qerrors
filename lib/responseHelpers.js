const sendJsonResponse=(res,status,data)=>res.status(status).json(data);const sendSuccessResponse=(res,data,options={})=>{const{includeProcessingTime=false,startTime=null}=options;const responseData={success:true,data};includeProcessingTime&&startTime&&(responseData.processingTime=Date.now()-startTime);return sendJsonResponse(res,200,responseData);}; const sendCreatedResponse = (res, data) => sendJsonResponse(res, 201, { success: true, data }); const sendErrorResponse = (res, status, message, details = null, options = {}) => { const { requestId = null, processingTime = null } = options; const responseData = { success: false, error: status, message }; requestId && (responseData.requestId = requestId); processingTime !== null && (responseData.processingTime = processingTime); if (details) { if (status === 400 && Array.isArray(details)) { responseData.errors = details; } else { responseData.details = details; } } return sendJsonResponse(res, status, responseData); }; const sendValidationErrorResponse = (res, errors, options = {}) => { const { requestId = null } = options; return sendErrorResponse(res, 400, 'Validation failed', errors, { requestId }); }; const sendNotFoundResponse = (res, message = 'Resource not found') => sendErrorResponse(res, 404, message); const sendUnauthorizedResponse = (res, message = 'Unauthorized') => sendErrorResponse(res, 401, message); const sendForbiddenResponse = (res, message = 'Forbidden') => sendErrorResponse(res, 403, message); const sendServerErrorResponse = (res, message = 'Internal server error') => sendErrorResponse(res, 500, message); const createResponseHelper = (res, startTime = null) => ({ success: (data, options = {}) => sendSuccessResponse(res, data, { ...options, startTime }), created: data => sendCreatedResponse(res, data), error: (status, message, details, options = {}) => sendErrorResponse(res, status, message, details, { ...options, startTime }), validation: (errors, options = {}) => sendValidationErrorResponse(res, errors, { ...options, startTime }), notFound: message => sendNotFoundResponse(res, message), unauthorized: message => sendUnauthorizedResponse(res, message), forbidden: message => sendForbiddenResponse(res, message), serverError: message => sendServerErrorResponse(res, message) }); const globalErrorHandler = (err, req, res, next) => { if (res.headersSent) return next(err); const status = err.status || err.statusCode || 500, expose = err.expose !== false && status < 500, message = expose ? err.message : 'Internal Server Error'; try { const utils = require('./utils'); if (typeof utils.safeQerrors === 'function') { utils.safeQerrors(err, 'globalErrorHandler', { status, path: req.path, method: req.method }).catch(() => {}); } } catch {} if (!res.headersSent) { res.status(status).json({ error: message, details: err.details || (expose && err instanceof Error ? err.message : undefined) }); } }; const handleError = async (error, context, res, next) => { try { const qerrors = await import('./qerrors.js'); if (qerrors.handleControllerError) { await qerrors.handleControllerError(res, error, context, {}); } else { const message = error instanceof Error ? error.message : 'Unknown error'; !res.headersSent && res.status(500).json({ error: message, context }); } } catch { const message = error instanceof Error ? error.message : 'Unknown error'; !res.headersSent && res.status(500).json({ error: message, context }); } }; module.exports = { sendJsonResponse, sendSuccessResponse, sendCreatedResponse, sendErrorResponse, sendValidationErrorResponse, sendNotFoundResponse, sendUnauthorizedResponse, sendForbiddenResponse, sendServerErrorResponse, createResponseHelper, globalErrorHandler, handleError };
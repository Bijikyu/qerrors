'use strict'; const { randomUUID } = require('crypto'); const ErrorTypes = { VALIDATION: 'validation', AUTHENTICATION: 'authentication', AUTHORIZATION: 'authorization', NOT_FOUND: 'not_found', RATE_LIMIT: 'rate_limit', NETWORK: 'network', DATABASE: 'database', SYSTEM: 'system', CONFIGURATION: 'configuration' }; const ErrorSeverity = { LOW: 'low', MEDIUM: 'medium', HIGH: 'high', CRITICAL: 'critical' }; const ERROR_STATUS_MAP = { [ErrorTypes.VALIDATION]: 400, [ErrorTypes.AUTHENTICATION]: 401, [ErrorTypes.AUTHORIZATION]: 403, [ErrorTypes.NOT_FOUND]: 404, [ErrorTypes.RATE_LIMIT]: 429, [ErrorTypes.NETWORK]: 502, [ErrorTypes.DATABASE]: 500, [ErrorTypes.SYSTEM]: 500, [ErrorTypes.CONFIGURATION]: 500 }; const ERROR_SEVERITY_MAP = { [ErrorTypes.VALIDATION]: ErrorSeverity.LOW, [ErrorTypes.AUTHENTICATION]: ErrorSeverity.LOW, [ErrorTypes.AUTHORIZATION]: ErrorSeverity.MEDIUM, [ErrorTypes.NOT_FOUND]: ErrorSeverity.LOW, [ErrorTypes.RATE_LIMIT]: ErrorSeverity.MEDIUM, [ErrorTypes.NETWORK]: ErrorSeverity.MEDIUM, [ErrorTypes.DATABASE]: ErrorSeverity.HIGH, [ErrorTypes.SYSTEM]: ErrorSeverity.HIGH, [ErrorTypes.CONFIGURATION]: ErrorSeverity.CRITICAL }; class ServiceError extends Error { constructor(message, type, context = {}, cause = null) { super(message); this.name = 'ServiceError'; this.type = type; this.context = context; this.cause = cause; this.statusCode = ERROR_STATUS_MAP[type] || 500; this.severity = ERROR_SEVERITY_MAP[type] || ErrorSeverity.MEDIUM; this.timestamp = new Date().toISOString(); Error.captureStackTrace && Error.captureStackTrace(this, ServiceError); } toJSON() { return { name: this.name, message: this.message, type: this.type, context: this.context, statusCode: this.statusCode, severity: this.severity, timestamp: this.timestamp, cause: this.cause ? { message: this.cause.message, stack: this.cause.stack } : null }; } } const errorUtils = { validation: (field, value) => { const message = value === undefined || value === null || value === '' ? `${field} is required` : `Invalid ${field}: ${typeof value} ${value}`; return new ServiceError(message, ErrorTypes.VALIDATION, { field, value }); }, authentication: serviceName => new ServiceError(`${serviceName} authentication failed`, ErrorTypes.AUTHENTICATION, { serviceName }), authorization: action => new ServiceError(`Insufficient permissions to ${action}`, ErrorTypes.AUTHORIZATION, { action }), externalApi: (serviceName, originalError) => new ServiceError(`${serviceName} API error: ${originalError.message}`, ErrorTypes.NETWORK, { serviceName }, originalError), internal: (message, context = {}) => new ServiceError(message, ErrorTypes.SYSTEM, context), wrap: (error, defaultMessage) => { if (error instanceof ServiceError) return error; if (error instanceof Error) return new ServiceError(error.message, ErrorTypes.SYSTEM, undefined, error); return new ServiceError(defaultMessage, ErrorTypes.SYSTEM, { originalError: error }); }, asyncHandler: async (operation, errorMessage) => { try { return await operation(); } catch (error) { throw errorUtils.wrap(error, errorMessage); } } }; const safeUtils = { execute: async operation => { try { const data = await operation(); return { success: true, data }; } catch (error) { const serviceError = error instanceof ServiceError ? error : errorUtils.wrap(error, 'Operation failed'); return { success: false, error: serviceError }; } }, validate: (value, validator, field) => { try { const data = validator(value); return { success: true, data }; } catch (error) { const serviceError = errorUtils.wrap(error, `Validation failed for ${field}`); return { success: false, error: serviceError }; } } }; const getRequestId = req => { if (req && req.headers) { return req.headers['x-request-id'] || req.headers['x-correlation-id'] || req.headers['request-id'] || randomUUID(); } return randomUUID(); }; const createStandardError = (code, message, type, context = {}) => ({ code, message, type, timestamp: new Date().toISOString(), requestId: context.requestId || getRequestId(context.req), context: { ...context, req: undefined, res: undefined } }); const sendErrorResponse = (res, statusCode, errorObject) => { if (res && !res.headersSent) { res.status(statusCode).json({ error: errorObject }); } }; const createTypedError = (message, type, code = 'GENERIC_ERROR', context = {}) => { const error = new Error(message); error.type = type; error.code = code; error.context = context; error.statusCode = ERROR_STATUS_MAP[type] || 500; error.severity = ERROR_SEVERITY_MAP[type] || ErrorSeverity.MEDIUM; return error; }; const ErrorFactory = { validation: (message, field = null, context = {}) => createStandardError('VALIDATION_ERROR', message, ErrorTypes.VALIDATION, { ...context, field }), authentication: (message = 'Authentication required', context = {}) => createStandardError('AUTHENTICATION_ERROR', message, ErrorTypes.AUTHENTICATION, context), authorization: (message = 'Insufficient permissions', context = {}) => createStandardError('AUTHORIZATION_ERROR', message, ErrorTypes.AUTHORIZATION, context), notFound: (resource, context = {}) => createStandardError('NOT_FOUND', `${resource} not found`, ErrorTypes.NOT_FOUND, context), rateLimit: (message = 'Rate limit exceeded', context = {}) => createStandardError('RATE_LIMIT_EXCEEDED', message, ErrorTypes.RATE_LIMIT, context), network: (message, service = null, context = {}) => createStandardError('NETWORK_ERROR', message, ErrorTypes.NETWORK, { ...context, service }), database: (message, operation = null, context = {}) => createStandardError('DATABASE_ERROR', message, ErrorTypes.DATABASE, { ...context, operation }), system: (message, component = null, context = {}) => createStandardError('SYSTEM_ERROR', message, ErrorTypes.SYSTEM, { ...context, component }), from: (error, meta = {}) => { if (error instanceof Error) { if (meta && Object.keys(meta).length > 0) error.meta = meta; return error; } const err = new Error(String(error)); err.status = 500; err.meta = meta; return err; } }; const errorMiddleware = (error, req, res, next) => { try { const context = { req, url: req.url, method: req.method, ip: req.ip, userAgent: req.headers['user-agent'] }; const errorType = error.type || ErrorTypes.SYSTEM; const statusCode = ERROR_STATUS_MAP[errorType]; const errorResponse = createStandardError(error.code || 'INTERNAL_ERROR', error.message || 'An internal error occurred', errorType, context); if (!res.headersSent) sendErrorResponse(res, statusCode, errorResponse); } catch (metaError) { console.error('Meta-error in errorMiddleware:', metaError.message); if (!res.headersSent) { try { res.status(500).json({ error: { code: 'SYSTEM_ERROR', message: 'An internal error occurred', timestamp: new Date().toISOString() } }); } catch (finalError) { console.error('Final error in errorMiddleware:', finalError.message); !res.headersSent && res.status(500).end(); } } } }; const handleSimpleError = (res, error, message, req) => { try { const qerrors = require('./qerrors'); if (req) qerrors(error, message, req); else qerrors(error, message); if (!res.headersSent) { const errorResponse = createStandardError('INTERNAL_ERROR', message, ErrorTypes.SYSTEM, {}); sendErrorResponse(res, 500, errorResponse); } } catch (metaError) { console.error('Meta-error in handleSimpleError:', metaError.message); if (!res.headersSent) { try { res.status(500).json({ error: message }); } catch (finalError) { console.error('Final error in handleSimpleError:', finalError.message); res.status(500).end(); } } } }; module.exports = { ErrorTypes, ErrorSeverity, ERROR_STATUS_MAP, ERROR_SEVERITY_MAP, getRequestId, createStandardError, sendErrorResponse, createTypedError, ErrorFactory, errorMiddleware, handleSimpleError, ServiceError, errorUtils, safeUtils };
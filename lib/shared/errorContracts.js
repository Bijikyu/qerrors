/**
 * Unified Error Handling Contracts Module
 * 
 * Purpose: Provides comprehensive error handling framework with
 * standardized contracts, severity classification, and response
 * formatting. This module implements consistent error processing
 * across all qerrors components.
 * 
 * Key Features:
 * - Error classification by type and severity
 * - Standardized error response formatting
 * - Security-conscious error message generation
 * - Performance-aware error logging
 * - Express middleware integration
 * - Custom error handler support
 * 
 * Design Philosophy:
 * - Consistency: All errors follow same processing pattern
 * - Security: Sensitive information is protected in responses
 * - Performance: Error handling never blocks application flow
 * - Flexibility: Support for custom handlers and middleware
 * - Observability: Rich error context and tracking information
 */

const localVars = require('../../config/localVars');
const { LOG_LEVELS } = localVars;
const { safeLogError, safeLogWarn, safeLogInfo, safeLogDebug } = require('./logging');
const { OperationContractValidator } = require('./contracts');

// Error severity mapping imported from localVars
const { ERROR_SEVERITY_MAP_CONTRACTS: ERROR_SEVERITY_MAP } = localVars;

/**
 * Standard error response structure
 * 
 * This template defines the base structure for all error responses
 * generated by qerrors module. It ensures consistency in error
 * reporting across different contexts and interfaces.
 */
const { STANDARD_ERROR_RESPONSE } = localVars;

/**
 * Input validation utilities for enhanced security
 */

/**
 * Sanitize and validate error input to prevent security issues
 * @param {*} error - Error input to validate
 * @returns {Error} Sanitized error object
 */
function sanitizeErrorInput(error) {
  // Handle null/undefined inputs
  if (error === null || error === undefined) {
    return new Error('Unknown error occurred');
  }
  
  // Ensure we have an Error object
  if (!(error instanceof Error)) {
    if (typeof error === 'string') {
      // Limit string length to prevent DoS
      const sanitized = String(error).slice(0, 1000);
      return new Error(sanitized);
    } else if (typeof error === 'object') {
      // Convert object to error with safe serialization
      try {
        const message = JSON.stringify(error).slice(0, 1000);
        return new Error(message);
      } catch (serializeError) {
        return new Error('Object error could not be serialized');
      }
    } else {
      return new Error(String(error).slice(0, 1000));
    }
  }
  
  // Validate and sanitize error properties
  const sanitizedError = new Error(error.message ? String(error.message).slice(0, 1000) : 'Error occurred');
  sanitizedError.name = error.name ? String(error.name).slice(0, 100) : 'Error';
  
  // Copy safe properties only
  if (error.code && typeof error.code === 'string' && error.code.length < 100) {
    sanitizedError.code = error.code;
  }
  if (error.status && (typeof error.status === 'number' && error.status >= 100 && error.status < 1000)) {
    sanitizedError.status = error.status;
  }
  if (error.statusCode && (typeof error.statusCode === 'number' && error.statusCode >= 100 && error.statusCode < 1000)) {
    sanitizedError.statusCode = error.statusCode;
  }
  
  // Limit stack trace length
  if (error.stack) {
    sanitizedError.stack = String(error.stack).slice(0, 5000);
  }
  
  return sanitizedError;
}

/**
 * Validate options object for error handling
 * @param {*} options - Options to validate
 * @returns {Object} Sanitized options object
 */
function sanitizeErrorOptions(options) {
  if (!options || typeof options !== 'object') {
    return {};
  }
  
  const sanitized = {};
  
  // Only allow known safe properties
  const allowedProperties = [
    'operationName', 'requestId', 'context', 'shouldLog', 'customHandler'
  ];
  
  for (const prop of allowedProperties) {
    if (Object.prototype.hasOwnProperty.call(options, prop) && options[prop] !== undefined) {
      if (prop === 'operationName' || prop === 'requestId') {
        // Limit string length
        sanitized[prop] = typeof options[prop] === 'string' ? 
          options[prop].slice(0, 200) : String(options[prop]).slice(0, 200);
      } else if (prop === 'context' && options[prop] !== null && typeof options[prop] === 'object') {
        // Sanitize context object to reasonable size
        try {
          const contextStr = JSON.stringify(options[prop]);
          if (contextStr.length < 5000) {
            sanitized[prop] = options[prop];
          } else {
            sanitized[prop] = { truncated: true };
          }
        } catch (e) {
          sanitized[prop] = { serializationError: true };
        }
      } else if (prop === 'shouldLog') {
        // Ensure boolean
        sanitized[prop] = Boolean(options[prop]);
      } else if (prop === 'customHandler' && typeof options[prop] === 'function') {
        sanitized[prop] = options[prop];
      }
    }
  }
  
  return sanitized;
}

/**
 * Escape HTML to prevent XSS in error messages
 * @param {string} str - String to escape
 * @returns {string} HTML-escaped string
 */
function escapeHTML(str) {
  if (typeof str !== 'string') {
    return '';
  }
  
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/\//g, '&#x2F;');
}

/**
 * Unified Error Handler Class
 * 
 * Purpose: Implements comprehensive error processing pipeline with
 * classification, response formatting, logging, and custom handler
 * execution. This class provides the core error handling logic
 * used throughout qerrors module.
 * 
 * Error Handling Pipeline:
 * 1. Validate and sanitize error input and options
 * 2. Classify error by type and determine severity
 * 3. Create standardized response with security considerations
 * 4. Log error with appropriate level and context
 * 5. Execute custom error handler if provided
 * 6. Return consistent error response format
 */
class UnifiedErrorHandler {
  /**
   * Handle error with complete contract compliance
   * 
   * Purpose: Processes errors through comprehensive pipeline including
   * validation, classification, response creation, logging, and custom
   * handler execution. Implements defensive programming with multiple
   * fallback mechanisms.
   * 
   * Processing Steps:
   * - Validate error options against standard contract
   * - Classify error type and determine severity level
   * - Create security-conscious error response
   * - Log error with appropriate severity and context
   * - Execute custom error handler if specified
   * - Provide fallback if error handling fails
   * 
   * @param {Error} error - Error object to handle
   * @param {Object} options - Error handling options
   * @returns {Object} Standardized error response
   */
  static async handleError(error, options = {}) {
    // Sanitize inputs first
    const sanitizedError = sanitizeErrorInput(error);
    const sanitizedOptions = sanitizeErrorOptions(options);
    
    const validation = OperationContractValidator.validateErrorOptions({
      error: sanitizedError,
      ...sanitizedOptions
    });
    
    if (!validation.isValid) {
      // Fallback for invalid error options
      return this.createFallbackErrorResponse(sanitizedError, sanitizedOptions);
    }

    const normalizedOptions = validation.normalizedOptions;
    
    try {
      // Classify error by type and characteristics
      const errorClassification = this.classifyError(error);
      
      // Create standardized response with security considerations
      const response = this.createStandardErrorResponse(error, errorClassification, normalizedOptions);
      
      // Log error if enabled (with appropriate severity level)
      if (normalizedOptions.shouldLog) {
        await this.logError(error, response, normalizedOptions);
      }
      
      // Apply custom handler if provided (with error isolation)
      if (normalizedOptions.customHandler) {
        await this.applyCustomHandler(response, normalizedOptions);
      }
      
      return response;

    } catch (handlingError) {
      // Fallback if error handling itself fails (defensive programming)
      safeLogError('Error handling failed', {
        originalError: error.message,
        handlingError: handlingError.message,
        operationName: normalizedOptions.operationName
      });
      
      return this.createFallbackErrorResponse(error, normalizedOptions);
    }
  }

/**
 * Classify error by type and determine appropriate severity
 * 
 * Purpose: Analyzes error characteristics to categorize by type
 * and determine severity level. This classification drives response
 * formatting, logging level, and retry decisions.
 * 
 * Classification Categories:
 * - System Errors: Infrastructure, memory, network, system failures
 * - Business Logic Errors: Validation, authorization, not found, conflicts
 * - Operational Errors: Configuration, dependency, general operations
 * 
 * Severity Assignment Logic:
 * - System errors typically logged as ERROR
 * - Business logic errors typically logged as WARN or INFO
 * - Uses predefined severity mapping from configuration
 * - Can be overridden by custom classification rules
 * 
 * Classification Benefits:
 * - Consistent error categorization across modules
 * - Appropriate log level selection
 * - Intelligent retry decision making
 * - Security-conscious error responses
 * 
 * @param {Error} error - Error object to classify
 * @returns {Object} Error classification with category, severity, and flags
 */
  static classifyError(error) {
    const errorName = error.name.toUpperCase();
    const errorMessage = error.message.toLowerCase();
    
    let category = 'UNKNOWN_ERROR';
    let severity = LOG_LEVELS.ERROR;
    
    // System errors - typically indicate infrastructure or resource issues
    if (errorMessage.includes('timeout') || errorName.includes('TIMEOUT')) {
      category = 'TIMEOUT_ERROR';
    } else if (errorMessage.includes('memory') || errorMessage.includes('heap')) {
      category = 'MEMORY_ERROR';
    } else if (errorMessage.includes('network') || errorMessage.includes('connection') || 
               errorMessage.includes('ECONN') || errorMessage.includes('ENOTFOUND')) {
      category = 'NETWORK_ERROR';
    } else if (errorName.includes('SYSTEM') || errorMessage.includes('system')) {
      category = 'SYSTEM_ERROR';
    }
    
    // Business logic errors - typically user-facing issues
    else if (errorName.includes('VALIDATION') || errorMessage.includes('validation') || 
             errorMessage.includes('invalid') || errorMessage.includes('required')) {
      category = 'VALIDATION_ERROR';
      severity = LOG_LEVELS.WARN;
    } else if (errorName.includes('AUTHORIZATION') || errorMessage.includes('unauthorized') || 
               errorMessage.includes('forbidden') || errorMessage.includes('access denied')) {
      category = 'AUTHORIZATION_ERROR';
      severity = LOG_LEVELS.WARN;
    } else if (errorName.includes('NOT_FOUND') || errorMessage.includes('not found') || 
               errorMessage.includes('404')) {
      category = 'NOT_FOUND_ERROR';
      severity = LOG_LEVELS.INFO;
    } else if (errorName.includes('CONFLICT') || errorMessage.includes('conflict') || 
               errorMessage.includes('duplicate')) {
      category = 'CONFLICT_ERROR';
      severity = LOG_LEVELS.WARN;
    }
    
    // Operational errors - typically configuration or dependency issues
    else if (errorName.includes('CONFIGURATION') || errorMessage.includes('configuration') || 
             errorMessage.includes('config')) {
      category = 'CONFIGURATION_ERROR';
    } else if (errorMessage.includes('dependency') || errorMessage.includes('service unavailable')) {
      category = 'DEPENDENCY_ERROR';
    } else {
      category = 'OPERATION_ERROR';
    }
    
    // Map category to severity using predefined mapping
    severity = ERROR_SEVERITY_MAP[category] || LOG_LEVELS.ERROR;
    
    return {
      category,
      severity,
      isSystemError: severity === LOG_LEVELS.ERROR && !category.includes('OPERATION'),
      isBusinessError: severity === LOG_LEVELS.WARN || severity === LOG_LEVELS.INFO,
      isRetryable: this.isRetryableError(category, error)
    };
  }

  /**
   * Determine if error is retryable
   * @param {string} category - Error category
   * @param {Error} error - Error object
   * @returns {boolean} Whether error is retryable
   */
  static isRetryableError(category, error) {
    const retryableCategories = [
      'NETWORK_ERROR',
      'TIMEOUT_ERROR',
      'DEPENDENCY_ERROR'
    ];
    
    const retryablePatterns = [
      /timeout/i,
      /connection/i,
      /network/i,
      /temporary/i,
      /unavailable/i
    ];
    
    return retryableCategories.includes(category) || 
           retryablePatterns.some(pattern => pattern.test(error.message));
  }

  /**
   * Create standardized error response
   * @param {Error} error - Original error
   * @param {Object} classification - Error classification
   * @param {Object} options - Normalized options
   * @returns {Object} Standard error response
   */
  static createStandardErrorResponse(error, classification, options) {
    return {
      ...STANDARD_ERROR_RESPONSE,
      error: {
        code: this.generateErrorCode(error, classification),
        message: this.generateErrorMessage(error, classification),
        severity: classification.severity,
        category: classification.category,
        details: this.extractErrorDetails(error),
        isRetryable: classification.isRetryable
      },
      metadata: {
        timestamp: new Date().toISOString(),
        operationName: options.operationName,
        requestId: options.requestId,
        stackTrace: error.stack
      },
      context: {
        ...options.context,
        errorName: error.name,
        errorMessage: error.message
      }
    };
  }

  /**
   * Generate standardized error code
   * @param {Error} error - Error object
   * @param {Object} classification - Error classification
   * @returns {string} Error code
   */
  static generateErrorCode(error, classification) {
    const prefix = classification.category.replace('_ERROR', '');
    const suffix = error.code ? `_${error.code}` : '';
    return `${prefix}${suffix}`.toUpperCase();
  }

  /**
   * Generate user-friendly error message
   * @param {Error} error - Original error
   * @param {Object} classification - Error classification
   * @returns {string} User-friendly message
   */
  static generateErrorMessage(error, classification) {
    // System errors should be generic for security
    if (classification.isSystemError) {
      return 'An internal system error occurred. Please try again later.';
    }
    
    // Business logic errors can be more specific
    if (classification.isBusinessError) {
      return escapeHTML(error.message) || 'A validation error occurred.';
    }
    
    // Operational errors
    if (classification.category === 'TIMEOUT_ERROR') {
      return 'The operation timed out. Please try again.';
    }
    
    if (classification.category === 'NETWORK_ERROR') {
      return 'A network error occurred. Please check your connection and try again.';
    }
    
    return escapeHTML(error.message) || 'An error occurred during operation.';
  }

  /**
   * Extract relevant error details
   * @param {Error} error - Error object
   * @returns {Object} Error details
   */
  static extractErrorDetails(error) {
    const details = {};
    
    // Include common error properties
    if (error.code) details.code = error.code;
    if (error.status) details.status = error.status;
    if (error.statusCode) details.statusCode = error.statusCode;
    
    // Include validation errors
    if (error.details) details.validation = error.details;
    if (error.errors) details.errors = error.errors;
    
    // Include network error details
    if (error.hostname) details.hostname = error.hostname;
    if (error.port) details.port = error.port;
    
    return Object.keys(details).length > 0 ? details : null;
  }

  /**
   * Log error with standardized format (optimized for scalability)
   * @param {Error} error - Original error
   * @param {Object} response - Error response
   * @param {Object} options - Error options
   */
  static async logError(error, response, options) {
    // Pre-build log data to avoid repeated object property access
    const logData = {
      requestId: options.requestId,
      operationName: options.operationName,
      errorCode: response.error.code,
      errorCategory: response.error.category,
      errorSeverity: response.error.severity,
      isRetryable: response.error.isRetryable,
      context: options.context
    };
    
    // Use direct function reference instead of switch for better performance
    const logMessage = `[${response.error.code}] ${response.error.message}`;
    const logLevel = response.error.severity;
    
    if (logLevel === LOG_LEVELS.ERROR) {
      safeLogError(logMessage, logData);
    } else if (logLevel === LOG_LEVELS.WARN) {
      safeLogWarn(logMessage, logData);
    } else if (logLevel === LOG_LEVELS.INFO) {
      safeLogInfo(logMessage, logData);
    } else {
      safeLogDebug(logMessage, logData);
    }
  }

  /**
   * Apply custom error handler
   * @param {Object} response - Error response
   * @param {Object} options - Error options
   */
  static async applyCustomHandler(response, options) {
    try {
      await options.customHandler(response, options);
    } catch (customError) {
      safeLogError('Custom error handler failed', {
        originalError: response.error.message,
        customError: customError.message,
        operationName: options.operationName,
        requestId: options.requestId
      });
    }
  }

  /**
   * Create fallback error response
   * @param {Error} error - Original error
   * @param {Object} options - Error options
   * @returns {Object} Fallback response
   */
  static createFallbackErrorResponse(error, options = {}) {
    return {
      success: false,
      error: {
        code: 'FALLBACK_ERROR',
        message: 'An error occurred and could not be processed normally.',
        severity: LOG_LEVELS.ERROR,
        category: 'UNKNOWN_ERROR',
        details: null
      },
      metadata: {
        timestamp: new Date().toISOString(),
        operationName: options.operationName || 'unknown',
        requestId: options.requestId || null
      },
      context: options.context || {}
    };
  }
}

/**
 * Express middleware for unified error handling
 */
function unifiedErrorMiddleware(options = {}) {
  return async (error, req, res, next) => {
    try {
      const errorResponse = await UnifiedErrorHandler.handleError(error, {
        operationName: 'express_request',
        requestId: req.id || req.headers['x-request-id'],
        context: {
          method: req.method,
          url: req.url,
          userAgent: req.headers['user-agent'],
          ip: req.ip
        },
        shouldLog: true,
        ...options
      });
      
      // Determine appropriate HTTP status
      const httpStatus = mapErrorToHttpStatus(errorResponse.error);
      
      // Send response
      res.status(httpStatus).json({
        success: false,
        error: {
          code: errorResponse.error.code,
          message: errorResponse.error.message,
          category: errorResponse.error.category
        },
        metadata: {
          requestId: errorResponse.metadata.requestId,
          timestamp: errorResponse.metadata.timestamp
        }
      });
      
    } catch (handlingError) {
      // Ultimate fallback
      console.error('Error handling middleware failed:', handlingError);
      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An internal error occurred'
        }
      });
    }
  };
}

/**
 * Map error category to HTTP status code
 * @param {Object} errorInfo - Error information
 * @returns {number} HTTP status code
 */
function mapErrorToHttpStatus(errorInfo) {
  if (!errorInfo || !errorInfo.category) {
    return 500;
  }
  switch (errorInfo.category) {
    case 'VALIDATION_ERROR':
      return 400;
    case 'AUTHORIZATION_ERROR':
      return 401;
    case 'NOT_FOUND_ERROR':
      return 404;
    case 'CONFLICT_ERROR':
      return 409;
    case 'TIMEOUT_ERROR':
      return 408;
    case 'DEPENDENCY_ERROR':
      return 503;
    case 'NETWORK_ERROR':
      return 503;
    case 'SYSTEM_ERROR':
    case 'CONFIGURATION_ERROR':
    case 'OPERATION_ERROR':
    default:
      return 500;
  }
}

module.exports = {
  UnifiedErrorHandler,
  unifiedErrorMiddleware,
  mapErrorToHttpStatus,
  ERROR_SEVERITY_MAP,
  STANDARD_ERROR_RESPONSE,
  sanitizeErrorInput,
  sanitizeErrorOptions,
  escapeHTML
};